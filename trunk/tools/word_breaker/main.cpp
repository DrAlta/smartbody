/*
 *  main.cpp - part of SBM: SmartBody Module
 *  Copyright (C) 2008  University of Southern California
 *
 *  SBM is free software: you can redistribute it and/or
 *  modify it under the terms of the Lesser GNU General Public License
 *  as published by the Free Software Foundation, version 3 of the
 *  license.
 *
 *  SBM is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  Lesser GNU General Public License for more details.
 *
 *  You should have received a copy of the Lesser GNU General Public
 *  License along with SBM.  If not, see:
 *      http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  CONTRIBUTORS:
 *      Arno Hartholt, USC
 */

#include "vhcl.h"

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <process.h>
#include <string>
#include <sstream> 
#include <fstream>

#include <xercesc/util/XMLUTF8Transcoder.hpp>
#include <xercesc/util/PlatformUtils.hpp>
#include <xercesc/util/XMLString.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/framework/LocalFileFormatTarget.hpp>
#if defined(XERCES_NEW_IOSTREAMS)
#include <iostream>
#else
#include <iostream.h>
#endif
#include <xercesc/util/OutOfMemoryException.hpp>
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/framework/MemBufInputSource.hpp>

#include "tt_utils.h"


XERCES_CPP_NAMESPACE_USE

using std::string;
using std::vector;
using std::map;


class XStr
{
public :
    XStr(const char* const toTranscode)
    {
        // Call the private transcoding method
        fUnicodeForm = XMLString::transcode(toTranscode);
    }

    ~XStr()
    {
        XMLString::release(&fUnicodeForm);
    }


    // -----------------------------------------------------------------------
    //  Getter methods
    // -----------------------------------------------------------------------
    const XMLCh* unicodeForm() const
    {
        return fUnicodeForm;
    }

private :
    // -----------------------------------------------------------------------
    //  Private data members
    //
    //  fUnicodeForm
    //      This is the Unicode XMLCh format of the string.
    // -----------------------------------------------------------------------
    XMLCh*   fUnicodeForm;
};

#define X(str) XStr(str).unicodeForm()


struct Marker  // Not used
{ 
   string id;
   string time;
};


struct Word   // Currently not used; markers are placed following protocol, see below
{
   string text;
   Marker first_marker;
   Marker second_marker;
};


struct Utterance
{
   string utterance_id;          // ID in NPC Editor / audio file name minus .wav
   string speech_id;             // sp1, etc. Static or dynamic? Generated by NVBG?
   string speaker;               
   string addressee;
   string text;                  // Whole utterance text
   vector<string> words;         // All the individual words in the utterance
   map<string, string> markers;  // Mapping of ID (T0, T1, etc.) to time. All the markers wrap around words. 
                                 // Assumed protocol: <marker T0/>word_0<marker T1/><marker T2/>word_1<marker T3/>
};


typedef map<string, string> markerType;

typedef map<string, Utterance> utteranceType;
utteranceType m_utterances;

bool m_reply_received = false;
char * m_request_message = "RemoteSpeechCmd";
char * m_reply_message = "RemoteSpeechReply";
string output_dir = "";
string m_speech_id_prefix = "sp";
string m_marker_id_prefix = "T";


string remove_double_quotes( string s )
{
   while(s.find("\"") != string::npos)
   {
      s.replace(s.find("\""), 1, "");
   }

   return s;
}


string int_to_string( int i )
{
   std::ostringstream ostr;
   ostr << i;
   return ostr.str();
}


void write_string_to_file( string name, string text )
{
   string file_name = name + ".bml";
   string path = output_dir + "/";
   string file = path + file_name;
   std::ofstream out( file.c_str() );
   if ( out )
   {
      out << text;
      out.close();
   }
   else 
   {
      printf( "\n\nError when trying to write to file '%s.wbb'.\n\nPress any key to exit.", file_name );
      _getch();
      exit(1);
   }
}


string create_bml( Utterance * ut )
{
   string result = "";
   int errorCode = 0;
   DOMImplementation * impl =  DOMImplementationRegistry::getDOMImplementation( X( "Core" ) );

   if ( impl != NULL )
   {
      try
      {
         XMLCh * id = XMLString::transcode( "id" );
         XMLCh * start = XMLString::transcode( "start" );
         XMLCh * ready = XMLString::transcode( "ready" );
         XMLCh * stroke = XMLString::transcode( "stroke" );
         XMLCh * relax = XMLString::transcode( "relax" );
         XMLCh * end = XMLString::transcode( "end" );
         XMLCh * time = XMLString::transcode( "time" );
         XMLCh * level = XMLString::transcode( "level" );
         XMLCh * type = XMLString::transcode( "type" );
         //XMLCh * ref = XMLString::transcode( "ref" );
         //XMLCh * viseme = XMLString::transcode( "viseme" );
         //XMLCh * articulation = XMLString::transcode( "articulation" );

         string first_marker_id = m_marker_id_prefix + int_to_string( 0 );
         string file_name = ut->utterance_id + ".wav";
         //XMLCh * id_value = XMLString::transcode( file_name.c_str() );

         DOMDocument* doc = impl->createDocument(
            0,                    // root element namespace URI.
            X( "bml" ),           // root element name
            0 );                  // document type object (DTD).

         //doc->setEncoding( X( "UTF-8" ) );
         doc->setXmlVersion( X( "1.0" ) );
         
         DOMElement * rootElement = doc->getDocumentElement();

         DOMElement * speechElement = doc->createElement( X( "speech" ) );
         speechElement->setAttribute( id, X( ut->speech_id.c_str() ) );
         speechElement->setAttribute( start, X( "0.0" ) );
         speechElement->setAttribute( ready, X( ut->markers[ first_marker_id ].c_str() ) );                                
         speechElement->setAttribute( stroke, X( "0" ) );                              // <----- TODO: How to get this??
         speechElement->setAttribute( relax, X( "0" ) );                               // <----- TODO: How to get this??
         speechElement->setAttribute( end, X( "0" ) );                                 // <----- TODO: How to get this??
         rootElement->appendChild( speechElement );

         DOMElement * textElement = doc->createElement( X( "text" ) );
         speechElement->appendChild( textElement );

         DOMElement * descriptionElement = doc->createElement( X( "description" ) );
         descriptionElement->setAttribute( level, X( "1" ));
         descriptionElement->setAttribute( type, X( "audio/x-wav" ));
         speechElement->appendChild( descriptionElement );

         DOMElement * fileElement = doc->createElement( X( "file" ) );
         fileElement->setAttribute( level, X( file_name.c_str() ));                         
         descriptionElement->appendChild( fileElement );

         // Add synch points (markers)
         for (unsigned int i = 0; i < ut->markers.size(); i++)
         {
            string key = m_marker_id_prefix + int_to_string( i );
            DOMElement * synchElement = doc->createElement( X( "sync" ) );
            synchElement->setAttribute( id, X( key.c_str() ) );
            synchElement->setAttribute( time, X( ut->markers[ key ].c_str() ) );
            textElement->appendChild( synchElement );
            
            // Add word
            if (i % 2 == 0)
            {
               DOMText * word = doc->createTextNode( X( ut->words.at( i / 2 ).c_str() ) );
               textElement->appendChild( word );
            }
         }



         DOMLSSerializer * theSerializer = DOMImplementation::getImplementation()->createLSSerializer();
         theSerializer->getDomConfig()->setParameter( X( "format-pretty-print" ), true);
         XMLCh * xml_result = theSerializer->writeToString( rootElement );
         result = XMLString::transcode( xml_result );
         printf( "XML Result: '%s'", result.c_str() );
         theSerializer->release();



      }
      catch ( const OutOfMemoryException & )
      {
         XERCES_STD_QUALIFIER cerr << "OutOfMemoryException" << XERCES_STD_QUALIFIER endl;
         errorCode = 5; 
      }
      catch ( const DOMException & e )
      {
         XERCES_STD_QUALIFIER cerr << "DOMException code is:  " << e.code << XERCES_STD_QUALIFIER endl;
         errorCode = 2;
      }
      catch ( const XMLException & toCatch )
      {
         printf( "XMLException occurred: %s", toCatch.getCode() );
         errorCode = 4;
      }
      catch (...)
      {
         XERCES_STD_QUALIFIER cerr << "An error occurred creating the document" << XERCES_STD_QUALIFIER endl;
         errorCode = 3;
      }
   }

   // TODO: Get this from Xerces
   string full_result = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>" + result;
   return full_result;
}


void tt_client_callback( char * op, char * args, void * user_data )
{
   // Parsers TTS reply message. Example message:
   // RemoteSpeechReply utah 1 OK: <?xml version="1.0" encoding="UTF-8"?><speak><soundFile name="C:\saso\saso\core\beavin\..\..\..\dimr\tmpaudio\utah-yer_new_to_town.wav"/>
   //   <viseme start="0.0" type="_"/>
   //   <viseme start="0.0" type="_"/>
   //   <mark name="sp1:T0" time="0.049977324263038546"/><word end="0.16997732426303855" start="0.049977324263038546">
   //      <viseme start="0.049977324263038546" type="OO"/>
   //      <viseme start="0.1199546485260771" type="Oh"/>
   //   </word><mark name="sp1:T2" time="0.16997732426303855"/><mark name="sp1:T1" time="0.16997732426303855"/>
   //   <word end="0.2619954648526077" start="0.16997732426303855">
   //      <viseme start="0.16997732426303855" type="Ih"/>
   //      <viseme start="0.22798185941043084" type="R"/>
   //   </word><mark name="sp1:T4" time="0.2619954648526077"/><mark name="sp1:T3" time="0.2619954648526077"/>
   //   <word end="0.3929705215419501" start="0.2619954648526077">
   //      <viseme start="0.2619954648526077" type="NG"/>
   //      <viseme start="0.28798185941043086" type="OO"/>
   //      <viseme start="0.35297052154195013" type="Oh"/>
   //   </word><mark name="sp1:T6" time="0.3929705215419501"/><mark name="sp1:T5" time="0.3929705215419501"/>
   //   <word end="0.5249886621315193" start="0.3929705215419501">
   //      <viseme start="0.3929705215419501" type="D"/>
   //      <viseme start="0.4799546485260771" type="Ih"/>
   //   </word><mark name="sp1:T8" time="0.5249886621315193"/><mark name="sp1:T7" time="0.5249886621315193"/>
   //   <word end="0.9479818594104309" start="0.5249886621315193">
   //      <viseme start="0.5249886621315193" type="D"/>
   //      <viseme start="0.6079818594104308" type="Ih"/>
   //      <viseme start="0.8379591836734694" type="NG"/>
   //   </word><mark name="sp1:T9" time="0.9479818594104309"/>
   //   <viseme start="0.9479818594104309" type="_"/>
   //   <viseme start="1.0029931972789117" type="_"/>
   //</speak>

   if ( strcmp( op, m_reply_message ) == 0 )
   {
      printf( "\nReceived - '%s %s'\n", op, args );

      string message_c = args;

      // parse the string
      std::vector< std::string > tokens;
      const string delimiters = " ";
      vhcl::Tokenize( message_c, tokens, delimiters );

      string agent_name = tokens.at( 0 );
      string message_id = tokens.at( 1 );
      string file_name = tokens.at( 2 );
      size_t prefix_length = message_c.find( file_name, 0 ) + file_name.length() + 1;
      string utterance = message_c.substr( prefix_length );  // strip off the prefix, only using the xml

      // remove anything after </speech> tag
      size_t postfix_pos = utterance.rfind( "</speech>" );
      if ( postfix_pos != string::npos )
         utterance = utterance.substr( 0, postfix_pos + 9 );

      // Parse response
      xercesc::XercesDOMParser * parser = new XercesDOMParser;

      parser->setValidationScheme( XercesDOMParser::Val_Never );
      parser->setDoNamespaces( false );
      parser->setDoSchema( false );
      parser->setLoadExternalDTD( false );
      
      // Tags
      //XMLCh * speak = XMLString::transcode( "speak" );
      //XMLCh * viseme = XMLString::transcode( "viseme" );
      XMLCh * mark = XMLString::transcode( "mark" );
      //XMLCh * word = XMLString::transcode( "word" );
      XMLCh * sound_file = XMLString::transcode( "soundFile" );

      // Attributes
      XMLCh * name = XMLString::transcode( "name" );
      //XMLCh * start = XMLString::transcode( "start" );
      //XMLCh * end = XMLString::transcode( "end" );
      XMLCh * time = XMLString::transcode( "time" );
      //XMLCh * type = XMLString::transcode( "type" );
      
      string utterance_id = "";;

      try
      {
         MemBufInputSource inputSource( (const XMLByte*)utterance.c_str(), (unsigned int)strlen(utterance.c_str()), "XMLBuffer" );
         parser->parse( inputSource );

         // no need to free this pointer - owned by the parent parser object
         DOMDocument* xmlDoc = parser->getDocument();

         // Get the top-level element ("speak")
         DOMElement* elementRoot = xmlDoc->getDocumentElement();
         if( !elementRoot ) throw(std::runtime_error( "empty XML document" ));

         DOMNodeList*      children = elementRoot->getChildNodes();
         const  XMLSize_t nodeCount = children->getLength();

         // First find utterance_id 
         for( XMLSize_t xx = 0; xx < nodeCount; ++xx )
         {
            DOMNode* currentNode = children->item(xx);
            if( currentNode->getNodeType() &&  // true is not NULL
               currentNode->getNodeType() == DOMNode::ELEMENT_NODE ) // is element 
            {
                // Found node which is an Element. Re-cast node as element
               DOMElement* currentElement = dynamic_cast< xercesc::DOMElement* >( currentNode );

               // If element is soundFile tag, get name and parse it, so we get our utterance ID
               if( XMLString::equals(currentElement->getTagName(), sound_file))
               {
                  const XMLCh* xmlch_name  = currentElement->getAttribute(name);
                  utterance_id = XMLString::transcode(xmlch_name);
                  // Get rid of path and extension to obtain ID
                  size_t last_slash = utterance_id.rfind( "\\" );
                  if ( last_slash != string::npos )
                     utterance_id = utterance_id.substr( last_slash + 1, utterance_id.size() );
                  utterance_id = utterance_id.substr( 0, utterance_id.size() - 4 );
                  break;
               }
            }
         }

         if ( utterance_id == "" )
         {
            printf( "\n\nERROR while parsing TTS reply: no soundFile tag.\n\nPress any key to exit.\n" );
            _getch();
            exit(1);
         }
         else
         {
            Utterance * ut = &m_utterances[ utterance_id ];

            // Now look for all the markers and add their timing info to the Utterance
            for( XMLSize_t xx = 0; xx < nodeCount; ++xx )
            {
               DOMNode* currentNode = children->item(xx);
               if( currentNode->getNodeType() &&  // true is not NULL
                  currentNode->getNodeType() == DOMNode::ELEMENT_NODE ) // is element 
               {
                  DOMElement* currentElement = dynamic_cast< xercesc::DOMElement* >( currentNode );
                  if( XMLString::equals(currentElement->getTagName(), mark))
                  {
                     const XMLCh* xmlch_name  = currentElement->getAttribute(name);
                     string name = XMLString::transcode(xmlch_name);

                     const XMLCh* xmlch_time  = currentElement->getAttribute(time);
                     string time = XMLString::transcode(xmlch_time);
                     
                     ut->markers[ name ] = time;
                  }
               }
            }
            // Write to file
            write_string_to_file( utterance_id, create_bml( ut ) );
         }

      }
      catch( xercesc::XMLException& e )
      {
         char * message = xercesc::XMLString::transcode( e.getMessage() );
         XERCES_STD_QUALIFIER cerr << "An error occurred parsing the document" << message << XERCES_STD_QUALIFIER endl;
         XMLString::release( &message );
      }

      m_reply_received = true;
   }
   else if ( strcmp( op, "vrKillComponent" ) == 0 )
   {
      if ( _stricmp( args, "word_breaker" ) == 0 ||
         _stricmp( args, "all" ) == 0 )
      {
         exit(0);
      }
   }
}


void elvin_loop( void * ignore )
{
   while ( m_reply_received == false )
   {
      ttu_wait( 0.5 );
   }

   _endthread();
}


void init_messaging()
{
   char * elvish_session_host = getenv( "ELVISH_SESSION_HOST" );
   if ( elvish_session_host == NULL )
   {
      elvish_session_host = "localhost";
   }

   printf( "ELVISH_SESSION_HOST: %s\n", elvish_session_host );
   printf( "ELVISH_SCOPE: %s\n", getenv( TTU_ENV_SCOPE ) );

   ttu_set_client_callback( tt_client_callback );
   int err = ttu_open( elvish_session_host );
   if ( err == TTU_SUCCESS )
   {
      err = ttu_register( m_request_message );
      err = ttu_register( m_reply_message );
      err = ttu_register( "vrKillComponent" );
   }
   else
   {
      printf( "An error occured while tring to establish ActiveMQ connection.\n\nPress any key to exit.\n" );
      _getch();
      exit(1);
   }
}


void init_XML()
{
   try
   {
      XMLPlatformUtils::Initialize();
   }
   catch ( const XMLException & toCatch )
   {
      char * pMsg = XMLString::transcode( toCatch.getMessage() );
      XERCES_STD_QUALIFIER cerr << "Error during Xerces-c Initialization.\n" << "  Exception message:" << pMsg;
      XMLString::release( &pMsg );
   }
}


// Creates TTS request message. Example message:
// RemoteSpeechCmd speak utah 1 M021 utah-yer_new_to_town.wav <?xml version="1.0" encoding="UTF-8"?><speech id="sp1" ref="" type="application/ssml+xml">
//	 <mark name="sp1:T0" />you 
//	 <mark name="sp1:T1" />
//	 <mark name="sp1:T2" />are
//	 <mark name="sp1:T3" />
//	 <mark name="sp1:T4" />new
//	 <mark name="sp1:T5" />
//	 <mark name="sp1:T6" />to
//	 <mark name="sp1:T7" />
//	 <mark name="sp1:T8" />town
//	 <mark name="sp1:T9" />
//	 </speech>
string create_tts_request( string utterance_id )
{
   Utterance * ut = &m_utterances[ utterance_id ];

   // For each word, attach numbered markers before and after it
   string words_and_markers = ""; 
   string mark_id = "T";
   string mark_begin = "<mark name=\"";
   string mark_end = "\"/>";

   std::vector<Marker> markers; 

   for (unsigned int i = 0; i < ut->words.size(); i++ )
   {
      string mrkr_id = mark_id + int_to_string( i * 2 );
      string marker1 = mark_begin + mrkr_id + mark_end;
      ut->markers[ mrkr_id ] = "-1";

      mrkr_id = mark_id + int_to_string( i * 2 + 1 );
      string marker2 = mark_begin + mrkr_id + mark_end;
      ut->markers[ mrkr_id ] = "-1";

      words_and_markers += marker1 + ut->words.at( i ) + marker2;
   }

   string xml = "speak " + ut->speaker + " 1 M021 " + ut->utterance_id + ".wav <?xml version=\"1.0\" encoding=\"UTF-8\"?>"
      "<speech id=\"" + ut->speech_id + "\" ref=\"\" type=\"application/ssml+xml\">" + words_and_markers + "</speech>";

   return xml;
}


int main( int argc, char * argv[] )
{
   char * input_file = NULL;
   std::vector<string> error_utterances;
   //bool quit = false;

   // Parse command line parameters
   for (int i = 1; i < argc; i += 2)
   {
      if ( argc <= i+1)
      {
         printf( "Missing argument for parameter %s.\n\nPress any key to exit.\n", argv[ i ] );
         _getch();
         exit(1);
      } 
      else if ( strcmp( argv[ i ], "-input" ) == 0 )
      {
         printf( "Input file: %s\n", argv[ i + 1 ] );
         input_file = argv[ i + 1 ];
      } 
      else if ( strcmp( argv[ i ], "-output" ) == 0 )
      {
         printf( "Output directory: %s\n", argv[ i + 1 ] );
         output_dir = argv[ i + 1 ];
      } 
      else 
      {
         printf( "Unknown argument '%s'. \n\n"
            "Known arguments:\n"
            "-input <input_file_name>, file with utterances text and ID tuples.\n"
            "-output <output_directory_name>, location where word break boundary timing files will be saved.\n\n"
            "Press any key to exit.\n", argv[ i ] );
         _getch();
         exit(1);
      }
   }

   // Initialize ActiveMQ
   init_messaging();

   // Init Xerces
   init_XML();

   // Read input file
   std::ifstream in( input_file );
   string s;
   int counter = 1;
   if ( in )
   {
      // Get tab-delimited lines (utterance_id, utterance_text)
      while ( getline( in, s ) )
      {
         //printf( "u_id: '%s'\n", s.c_str() );
         s = remove_double_quotes( s );

         // Split up line in key and text 
         std::vector< string > main_tokens;
         const string tab_delimiter = "\t";
         vhcl::Tokenize( s, main_tokens, tab_delimiter );

         // Split up text in words
         std::vector< string > word_tokens;
         const string space_delimiter = " ";
         vhcl::Tokenize( main_tokens.at( 1 ), word_tokens, space_delimiter );

         // Create Utterance struct
         struct Utterance ut;
         ut.utterance_id = main_tokens.at( 0 );
         ut.speech_id = "sp" + int_to_string( counter );
         ut.text = main_tokens.at( 1 );
         ut.addressee = "all";
         ut.speaker = "uknown";
         ut.words = word_tokens;
         map<string, string> markers;
         ut.markers = markers;

         // Add struct to map
         m_utterances[ ut.utterance_id ] = ut;

         counter++;
      }

      // TTS interaction
      string xml_request = "";
      // For each utterance
      for(utteranceType::const_iterator it = m_utterances.begin(); it != m_utterances.end(); ++it)
      {
         printf( "Key (ID): '%s'\n", it->first.c_str() );
         printf( "Text '%s'\n\n", it->second.text.c_str() );

         // Create xml request to send to TTS
         xml_request = create_tts_request( it->second.utterance_id );

         // Send request to TTS
         ttu_notify2( m_request_message, xml_request.c_str() );

         // Wait for response
         _beginthread( elvin_loop, 0, NULL );
         int timer = 0;
         while ( !m_reply_received )
         {
            Sleep( 100 );
            timer += 100;
            if ( timer > 3000 ) {
               error_utterances.push_back( it->second.utterance_id );
               m_reply_received = true;
            }
         }

         m_reply_received = false;

      }
   }  
   else
   {
      printf( "\nFile '%s' could not be opened. Please check if file exists. \n\nPress any key to exit.\n", input_file );
      _getch();
      exit(1);
   }

   for ( unsigned int i = 0; i < error_utterances.size(); i++ )
   {
      printf( "\n\n\nSkipped utterances:\n" );
      printf( "- %s\n", error_utterances.at( i ).c_str() ); 
   }

   printf(" \nPress any key to exit.\n ");
   _getch();
   ttu_close();

   return 0;
}
