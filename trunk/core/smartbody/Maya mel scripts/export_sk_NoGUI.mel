//  export_sk_NoGUI.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Matt Liewer, USC
//      Andrew n marshall, USC
//      Kristin Parker, USC



////////////////////////////////////////////////////////////////
//  FUNCTIONALITY:
//  Exports animation skeleton in .sk format for SmartBody
//  Requires SkViewer to bind the .objs to the .sk skeleton
//
//  UPDATES:
//  Updates: Removed GUI so can run in batch mode - Kristin Parker
////////////////////////////////////////////////////////////////



// --------------------------------------------------------------------------------
// PROC: skRound
// This will round a number to a certain precision, the bulk of this script actuall deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if (`substring $valueString 1 1` == "-") {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ($value * $multiplyer) ;
   $value = ($value + 0.5) ;
   $value = `trunc $value` ;
   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;
   //print ($value + "\n") ;
   //print ("StringSize: " + $StringSize + "\n") ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ($StringSize <= 5) {

      $SmallValues = 1 ;

      int $dif = (5 - $StringSize) ;
      if ($dif == 4) {
         $zeroes = "0000" ;
      }
      else if ($dif == 3) {
         $zeroes = "000" ;
      }
      else if ($dif == 2) {
         $zeroes = "00" ;
      }
      else if ($dif == 1) {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ($zeroes + $valueString) ;
      //print ($valueString + "\n") ;
   }

   //Assemble new strings
   if ($SmallValues == 1) {
      $wholeNumber = "0" ;
   }
   else {
      $wholeNumber = `substring $valueString 1 ($StringSize-$precision)` ;
   }

   $decNumber = `substring $valueString ($StringSize-($precision-1)) ($StringSize)` ;  //this seems unneccesarry

   $valueString = ($sign + $wholeNumber + "." + $decNumber) ;

   //Finish
   return $valueString ;


/*
   Old function
   float $precision = 5;
   $power = pow( 10, $precision );
   $value = $value * $power;
   $value = int ( $value + ( $value < 0 ? -0.5 : 0.5 ) );
   $value = $value / $power;
   return $value;
*/
}


proc int skMargin( int $fileid, int $depth )
{
   for ( $k = 0; $k < $depth; $k++ )
      fprint $fileid ("  ");

   return 1;
}


proc int skWriteSk( string $jname, int $fileid, int $depth, int $showAll, int $useLimits )
{
   //=== Get Children ===
   string $children[];
   $children = `listRelatives $jname`;
   int $nchildren = `size $children`;


   string $type = nodeType( $jname );


   // Write info for meshes
   if ( $type == "mesh" )
   {
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "visgeo \"" + $jname + ".obj\"\r\n" );
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "colgeo \"" + $jname + ".obj\"\r\n" );
   }


   // If object is not of type "joint" then recurse
   // HACK - initial_base is of type "transform", but we want to include it and not skip it.
   if ( $type != "joint" && $jname != "initial_base" )
   {
      if ( $type != "mesh" )
      {
         print( "Skipping " + $jname + ": " + $type + "\n" );
      }

      for ( $i = 0; $i < $nchildren; $i++ )
      {
         skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits );
      }

      return 1;
   }


   //=== Export Joint ===
   print( "Exporting joint " + $jname + "\n" );

   // Check if this is the root node of the hierarchy
   if ( $depth == 0 )
   {
      skMargin( $fileid, $depth );
      fprint $fileid ( "root " );
   }
   else
   {
      fprint $fileid ( "\r\n" );
      skMargin( $fileid, $depth );
      fprint $fileid ( "joint " );
   }

   fprint $fileid ( $jname + "\r\n" );

   skMargin ( $fileid, $depth );
   fprint $fileid ( "{ offset " );

   //Get and then write translation offsets
   float $offset[ 3 ];
   string $s = $jname + ".translateX";
   $offset[ 0 ] = `getAttr $s`;
   string $s = $jname + ".translateY";
   $offset[ 1 ] = `getAttr $s`;
   string $s = $jname + ".translateZ";
   $offset[ 2 ] = `getAttr $s`;

   fprint $fileid ( skRound( $offset[ 0 ] ) + " " + skRound( $offset[ 1 ] ) + " " + skRound( $offset[ 2 ] ) + "\r\n" );


   // Write translation channels and limits

   int $mntmn[] = ( `transformLimits -query -etx $jname` );
   float $xTransLimitValues[] = ( `transformLimits -query -tx $jname` );
   float $yTransLimitValues[] = ( `transformLimits -query -ty $jname` );
   float $zTransLimitValues[] = ( `transformLimits -query -tz $jname` );

   if ( $mntmn[ 0 ] && $mntmn[ 1 ] )
   {
      // limits exist
      if ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0" + " lim " + $xTransLimitValues[ 0 ] + " " + $xTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
      }

      if ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0" + " lim " + $yTransLimitValues[ 0 ] + " " + $yTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
      }

      if ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0" + " lim " + $zTransLimitValues[ 0 ] + " " + $zTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
   }
   else
   {
      if ( $showAll )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
      else if ( $jname == "base" )
      {
         // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis

         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
   }


   // Write rotation channel
   skMargin( $fileid, $depth + 1 );
   fprint $fileid ( "channel Quat\r\n" );


   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits );
   }


   //=== End ===
   skMargin( $fileid, $depth );
   fprint $fileid ( "}\r\n" );

   return 1;
}


global proc int export_sk_NoGUI( string $fname, string $skname, string $version, int $showAll, int $useLimits )
{
   int $fileid = `fopen $fname "w"`;
   if ( $fileid == 0 )
   {
      error( "Could not open file: " + $fname );
      return 0;
   }

   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected!\n";
   }

   int $selectionListSize = `size $selectionList`;
   int $depth = 0;

   // EDF - This loop seems intended for multiple characters, or in the instance where multiple objects may be in the scene besides the character
   //       These cases haven't been tested, and probably will not produce correct results.  Watch out for this loop.
   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      print ( "----------SK Export Report----------\n" );

      fprint $fileid ( "# SK Skeleton Definition\r\n" );
      fprint $fileid ( "# File generated with export_sk_v" + $version + ".mel\r\n\r\n" );
      fprint $fileid ( "set_name " + $skname + "\r\n\r\n" );
      fprint $fileid ( "skeleton\r\n" );

      skWriteSk( $selectionList[ $j ], $fileid, $depth, $showAll, $useLimits );

      fprint $fileid ( "\r\n" );
      fprint $fileid ( "end\r\n" );
   }

   fclose( $fileid );
   print( "Export done.\n" );
   return 1;
}


//
// - Three steps are required in order to export a new skeleton/character from Maya:
//   1. Use this mel script to export a .sk skeleton definition file
//   2. Use the obj exporter mel script to export the used rigid models.
//      Make sure the objs are saved to the same directory of the sk file.
//   3. Finally, load the sk file in the metool.exe (the character will appear
//      with the models in strange places), and select the menu option 
//      Tools->convert skeleton. A new correct skeleton (with srm geometries) will be created.
// - All joints are exported with quaternion rotation channel
// - Only base joint is exported with translation channels
// - Maya should be set to cms
// - If "Mirror Joint" is used to create the skeleton in Maya, be sure to use the
//   "orientation" option (not "behavior")
//
