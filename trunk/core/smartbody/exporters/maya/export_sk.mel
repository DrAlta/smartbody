//  export_sk.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Andrew n marshall, USC
//      Kristin Parker, USC


// - All joints are exported with quaternion rotation channel
// - Only base joint is exported with translation channels
// - If "Mirror Joint" is used to create the skeleton in Maya, be sure to use the
//   "orientation" option (not "behavior")


string $skVersion = "0.5";
global string $treeVisualization;

// --------------------------------------------------------------------------------
// PROC: skRound
// This will round a number to a certain precision, the bulk of this script actually deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if ( `substring $valueString 1 1` == "-" )
   {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ( $value * $multiplyer ) ;
   $value = ( $value + 0.5 ) ;
   $value = `trunc $value` ;
   
   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;

   //print ( $value + "\n" ) ;
   //print ( "StringSize: " + $StringSize + "\n" ) ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ( $StringSize <= 5 )
   {
      $SmallValues = 1 ;

      int $dif = ( 5 - $StringSize ) ;
      if ( $dif == 4 )
      {
         $zeroes = "0000" ;
      }
      else if ( $dif == 3 )
      {
         $zeroes = "000" ;
      }
      else if ( $dif == 2 )
      {
         $zeroes = "00" ;
      }
      else if ( $dif == 1 )
      {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ( $zeroes + $valueString ) ;

      //print ( $valueString + "\n" ) ;
   }

   //Assemble new strings
   if ( $SmallValues == 1 )
   {
      $wholeNumber = "0" ;
   }
   else
   {
      $wholeNumber = `substring $valueString 1 ( $StringSize - $precision )` ;
   }

   $decNumber = `substring $valueString ( $StringSize - ( $precision - 1 ) ) ( $StringSize )` ;  //this seems unneccesarry

   $valueString = ( $sign + $wholeNumber + "." + $decNumber ) ;

   return $valueString ;
}


proc int skMargin( int $fileid, int $depth )
{
   for ( $k = 0; $k < $depth; $k++ )
      fprint $fileid ("  ");

   return 1;
}

// make a quaternion from the given rotation around axis (x,y,z)
proc skmQuatSet( float $q[], float $x, float $y, float $z, float $degrees )
{
   float $radians = 3.1415926535897932 * $degrees / 180.0;

   // normalize axis:
   $q[ 1 ] = $x;
   $q[ 2 ] = $y;
   $q[ 3 ] = $z;

   float $f = $x * $x + $y * $y + $z * $z;

   if ( $f > 0 )
   {
      $f = sqrt( $f );
      $q[ 1 ] /= $f;
      $q[ 2 ] /= $f;
      $q[ 3 ] /= $f;
   }

   // set the quaternion:
   $radians /= 2;
   $f = sin( $radians );
   $q[ 1 ] *= $f;
   $q[ 2 ] *= $f;
   $q[ 3 ] *= $f;
   $q[ 0 ] = cos( $radians );
}


// quaternion multiplication
proc skmQuatMult( float $q[], float $q1[], float $q2[] )
{
   $q[ 0 ] = ( $q1[ 0 ] * $q2[ 0 ] ) - ( $q1[ 1 ] * $q2[ 1 ] + $q1[ 2 ] * $q2[ 2 ] + $q1[ 3 ] * $q2[ 3 ] ); // w1*w2-dot(v1,v2)
   $q[ 1 ] = $q1[ 2 ] * $q2[ 3 ] - $q1[ 3 ] * $q2[ 2 ]; // cross ($q1.v,$q2.v)
   $q[ 2 ] = $q1[ 3 ] * $q2[ 1 ] - $q1[ 1 ] * $q2[ 3 ];
   $q[ 3 ] = $q1[ 1 ] * $q2[ 2 ] - $q1[ 2 ] * $q2[ 1 ];
   $q[ 1 ] += ( $q1[ 1 ] * $q2[ 0 ] ) + ( $q2[ 1 ] * $q1[ 0 ] );
   $q[ 2 ] += ( $q1[ 2 ] * $q2[ 0 ] ) + ( $q2[ 2 ] * $q1[ 0 ] );
   $q[ 3 ] += ( $q1[ 3 ] * $q2[ 0 ] ) + ( $q2[ 3 ] * $q1[ 0 ] );
 }


// quaternion to axis-angle representation
proc quatToAxisAng( float $q[], float $aa[] )
{
   float $ang = 2.0 * acos( $q[ 0 ] );
   float $norm = sqrt( $q[ 1 ] * $q[ 1 ] + $q[ 2 ] * $q[ 2 ] + $q[ 3 ] * $q[ 3 ] );
   if ( $norm == 0 || $ang == 0 )
   {
      $aa[ 0 ] = 0;
      $aa[ 1 ] = 0;
      $aa[ 2 ] = 0;
   }
   else
   {
      $aa[ 0 ] = ( $q[ 1 ] / $norm ) ;
      $aa[ 1 ] = ( $q[ 2 ] / $norm ) ;
      $aa[ 2 ] = ( $q[ 3 ] / $norm ) ;
    }
	$aa[3] = $ang*180.0 / 3.1415926535897932;
}

proc eulerToAxisAngle( float $aa[], float $eu[] )
{

   float $rad[3];
   for ($i = 0; $i < 3 ; $i = $i + 1)   
        $rad[$i] = 3.1415926535897932 * $eu[$i] / 180.0;
		
	$c1 = cos($rad[2]/2);
	$s1 = sin($rad[2]/2);
	$c2 = cos($rad[1]/2);
	$s2 = sin($rad[1]/2);
	$c3 = cos($rad[0]/2);
	$s3 = sin($rad[0]/2);
	$c1c2 = $c1*$c2;
	$s1s2 = $s1*$s2;
	$w =$c1c2*$c3 - $s1s2*$s3;
	$x =$c1c2*$s3 + $s1s2*$c3;
	$y =$s1*$c2*$c3 + $c1*$s2*$s3;
	$z =$c1*$s2*$c3 - $s1*$c2*$s3;
	if ($w > 1.0)
		$w = 1.0;
	if ($w < -1.0)
		$w = -1.0;
		
	$angle = 2 * acos($w) * 180.0 / 3.1415926535897932;
	$norm = $x*$x+$y*$y+$z*$z;
	if ($norm < 0.001) { 
		$x=1;
		$y=0;
		$z=0;
	} else {
		$norm = sqrt($norm);
    	$x = $x / $norm;
    	$y = $y / $norm;
    	$z = $z / $norm;
	}	
	$aa[0] = $x;
	$aa[1] = $y;
	$aa[2] = $z;
	$aa[3] = $angle;	
}

proc eulerToAxisAngle2( float $aa[], float $eu[] )
{	
    float $qx[4], $qy[4],$qz[4];	
	skmQuatSet($qx,1,0,0,$eu[0]);
	skmQuatSet($qy,0,1,0,$eu[1]);
	skmQuatSet($qz,0,0,1,$eu[2]);
	
	float $qt1[4], $qt2[4];
	
	skmQuatMult($qt1,$qz,$qy);
	skmQuatMult($qt2,$qt1,$qx);
	
	quatToAxisAng($qt2,$aa);	
}


proc int skWriteSk( string $jname, int $fileid, int $depth, int $showAll, int $useLimits, int $useChannelAttributes )
{
   // RECURSIVE function
   
    //Declare variables
    int $TransXLimited[] = `transformLimits -query -etx $jname` ;
    int $TransYLimited[] = `transformLimits -query -ety $jname` ;
    int $TransZLimited[] = `transformLimits -query -etz $jname` ;
    float $xTransLimitValues[] = `transformLimits -query -tx $jname` ;
    float $yTransLimitValues[] = `transformLimits -query -ty $jname` ;
    float $zTransLimitValues[] = `transformLimits -query -tz $jname` ;
    int $printLimits = 0 ;


   //=== Get Children ===
   string $children[];
   $children = `listRelatives $jname`;
   int $nchildren = `size $children`;


   string $type = nodeType( $jname );


   // Write info for visible geometry meshes
   if ( $type == "mesh" )
   {
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "visgeo \"" + $jname + ".obj\"\r\n" );
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "colgeo \"" + $jname + ".obj\"\r\n" );
   }


   // If object is not of type "joint" then recurse
   // HACK - initial_base is of type "transform", but we want to include it and not skip it.
   if ( $type != "joint" && $jname != "initial_base" )
   {
      if ( $type != "mesh" )
      {
         print( "Skipping " + $jname + ": " + $type + "\n" );
      }

      for ( $i = 0; $i < $nchildren; $i++ )
      {
         skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits, $useChannelAttributes );
      }

      return 1;
   }


   //=== Export Joint ===
   print( "Exporting joint " + $jname + "\n" );

   // Check if this is the root node of the hierarchy
   if ( $depth == 0 )
   {
      skMargin( $fileid, $depth );
      fprint $fileid ( "root " );
   }
   else
   {
      fprint $fileid ( "\r\n" );
      skMargin( $fileid, $depth );
      fprint $fileid ( "joint " );
   }

   fprint $fileid ( $jname + "\r\n" );


   //Get and then write translation offsets
   float $offset[ 3 ];
   $offset[ 0 ] = `getAttr ( $jname + ".translateX" )`;
   $offset[ 1 ] = `getAttr ( $jname + ".translateY" )`;
   $offset[ 2 ] = `getAttr ( $jname + ".translateZ" )`;

   skMargin ( $fileid, $depth );
   fprint $fileid ( "{ offset " );
   fprint $fileid ( skRound( $offset[ 0 ] ) + " " + skRound( $offset[ 1 ] ) + " " + skRound( $offset[ 2 ] ) + "\r\n" );


   // check if the prerot joint attributes exist before adding the lines
   if ( `objExists ( $jname + ".jointOrientX" )` )
   {
      float $eulerRot[3]; 
      $eulerRot[ 0 ] = `getAttr ( $jname + ".jointOrientX" )`;
      $eulerRot[ 1 ] = `getAttr ( $jname + ".jointOrientY" )`;
      $eulerRot[ 2 ] = `getAttr ( $jname + ".jointOrientZ" )`;   
      float $prerot[4];   
      eulerToAxisAngle2($prerot, $eulerRot);
      skMargin( $fileid, $depth );
      fprint $fileid ( "  prerot " );
      fprint $fileid ( " axis " + skRound( $prerot[0] ) + " " + skRound( $prerot[ 1 ] ) + " " + skRound( $prerot[ 2 ] ) + " ang " + skRound( $prerot[ 3 ] )+ "\r\n" );
   }


   // Write translation channels and limits

   int $channelAttributePosX = 0;
   int $channelAttributePosY = 0;
   int $channelAttributePosZ = 0;
   int $channelAttributeQuat = 0;

   if ( $useChannelAttributes )
   {
      // if the attributes don't exist, add them to the joint
      if ( !`objExists ( $jname + ".SbodyPosX" )` )  addAttr -longName "SbodyPosX" -attributeType bool -defaultValue 0 $jname;
      if ( !`objExists ( $jname + ".SbodyPosY" )` )  addAttr -longName "SbodyPosY" -attributeType bool -defaultValue 0 $jname;
      if ( !`objExists ( $jname + ".SbodyPosZ" )` )  addAttr -longName "SbodyPosZ" -attributeType bool -defaultValue 0 $jname;
      if ( !`objExists ( $jname + ".SbodyQuat" )` )  addAttr -longName "SbodyQuat" -attributeType bool -defaultValue 0 $jname;

      $channelAttributePosX = `getAttr ( $jname + ".SbodyPosX" )`;
      $channelAttributePosY = `getAttr ( $jname + ".SbodyPosY" )`;
      $channelAttributePosZ = `getAttr ( $jname + ".SbodyPosZ" )`;
      $channelAttributeQuat = `getAttr ( $jname + ".SbodyQuat" )`;
   }

    //Print translate X channel: If limits are used, verify that they are correct and write them if not make the channel 'free'
    if ( $TransXLimited[0] && $TransXLimited[1]) {
        
        //Make sure limits do not equal each other
        $printLimits = 0;
        if ( ( $xTransLimitValues[0] != $xTransLimitValues[1] ) && ( $useLimits ) ){
            $printLimits = 1;
        }

        //Print limit values if channel attributes are used, the channel exists and limits are 
        //set up. If not leave the channel 'free'.
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosX ) {
                if ( $printLimits ) {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel XPos 0" + " lim " + $xTransLimitValues[ 0 ] + " " + $xTransLimitValues[ 1 ] + "\r\n" );
                }
                else {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel XPos 0 free\r\n" );
                }
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel XPos 0 free\r\n" );
            }
        }
    }
    else {
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosX ) {
                   skMargin( $fileid, $depth + 1 );
                   fprint $fileid ( "channel XPos 0 free\r\n" );
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel XPos 0 free\r\n" );
            }
            else if ( $jname == "base" ) {
            // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel XPos 0 free\r\n" );
            }
        }
    }
        
    //Print translate Y channel: If limits are used, verify that they are correct and write them if not make the channel 'free'
    if ( $TransYLimited[0] && $TransYLimited[1]) {

        //Make sure limits do not equal each other
        $printLimits = 0;
        if ( ( $yTransLimitValues[0] != $yTransLimitValues[1] ) && ( $useLimits ) ){
            $printLimits = 1;
        }

        //Print limit values if channel attributes are used, the channel exists and limits are 
        //set up. If not leave the channel 'free'.
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosY ) {
                if ( $printLimits ) {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel YPos 0" + " lim " + $yTransLimitValues[ 0 ] + " " + $yTransLimitValues[ 1 ] + "\r\n" );
                }
                else {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel YPos 0 free\r\n" );
                }
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel YPos 0 free\r\n" );
            }
        }
    }
    else {
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosY ) {
                   skMargin( $fileid, $depth + 1 );
                   fprint $fileid ( "channel YPos 0 free\r\n" );
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel YPos 0 free\r\n" );
            }
            else if ( $jname == "base" ) {
            // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel YPos 0 free\r\n" );
            }
        }
    } 
        
    //Print translate Z channel: If limits are used, verify that they are correct and write them if not make the channel 'free'
    if ( $TransZLimited[0] && $TransZLimited[1]) {

        //Make sure limits do not equal each other
        $printLimits = 0;
        if ( ( $zTransLimitValues[0] != $zTransLimitValues[1] ) && ( $useLimits ) ){
            $printLimits = 1;
        }

        //Print limit values if channel attributes are used, the channel exists and limits are 
        //set up. If not leave the channel 'free'.
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosZ ) {
                if ( $printLimits ) {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel ZPos 0" + " lim " + $zTransLimitValues[ 0 ] + " " + $zTransLimitValues[ 1 ] + "\r\n" );
                }
                else {
                    skMargin( $fileid, $depth + 1 );
                    fprint $fileid ( "channel ZPos 0 free\r\n" );
                }
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel ZPos 0 free\r\n" );
            }
        }
    }
    else {
        if ( $useChannelAttributes ) {
            if ( $channelAttributePosY ) {
                   skMargin( $fileid, $depth + 1 );
                   fprint $fileid ( "channel ZPos 0 free\r\n" );
            }
        }
        else {
            if ( $showAll ) {
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel ZPos 0 free\r\n" );
            }
            else if ( $jname == "base" ) {
            // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis
                skMargin( $fileid, $depth + 1 );
                fprint $fileid ( "channel ZPos 0 free\r\n" );
            }
        }
    }   
        
   // Write rotation channel
   if ( $useChannelAttributes )
   {
      if ( $channelAttributeQuat )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel Quat\r\n" );
      }
   }
   else
   {
      skMargin( $fileid, $depth + 1 );
      fprint $fileid ( "channel Quat\r\n" );
   }


   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits, $useChannelAttributes );
   }


   //=== End ===
   skMargin( $fileid, $depth );
   fprint $fileid ( "}\r\n" );

   return 1;
}


global proc int skExport( string $fname )
{
   // main entry point for exporting .sk file.
   // if you want to specify your own file name and location for .sk, then call this function.
   // to pull the file name from maya file, then call skExportButton()

   global string $skVersion;

   string $root   = `getAttr SkelDef.RootJoint`;
   string $skName = `getAttr SkelDef.SkeletonName`;
   int $showAll   = `getAttr SkelDef.ShowAllChannels`;
   int $useLimits = `getAttr SkelDef.UseLimits`;
   int $useChannelAttributes = `getAttr SkelDef.UseChannelAttributes`;
   string $UnitsLinear = `currentUnit -q -linear` ;

   select -r $root;


   print( "skExport() - $fname=" + $fname + " $skName=" + $skName + " $skVersion=" + $skVersion + " $showAll=" + $showAll + " $useLimits=" + $useLimits + " $useChannelAttributes=" + $useChannelAttributes + "\n" );


   int $fileid = `fopen $fname "w"`;
   if ( $fileid == 0 )
   {
      error( "Could not open file: " + $fname );
      return 0;
   }

   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected!\n";
   }

   int $selectionListSize = `size $selectionList`;
   int $depth = 0;

   // EDF - This loop seems intended for multiple characters, or in the instance where multiple objects may be in the scene besides the character
   //       These cases haven't been tested, and probably will not produce correct results.  Watch out for this loop.
   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      print ( "----------SK Export Report----------\n" );

      fprint $fileid ( "# SK Skeleton Definition\r\n" );
      fprint $fileid ( "# File generated with export_sk.mel v" + $skVersion + "    Units: " + $UnitsLinear + "\r\n\r\n" );
      fprint $fileid ( "set_name " + $skName + "\r\n\r\n" );
      fprint $fileid ( "skeleton\r\n" );

      skWriteSk( $selectionList[ $j ], $fileid, $depth, $showAll, $useLimits, $useChannelAttributes );

      fprint $fileid ( "\r\n" );
      fprint $fileid ( "end\r\n" );
   }

   fclose( $fileid );
   print( "Export done.\n" );
   return 1;
}






////////////////////////////////////////////////////////////////
//  GUI CODE
////////////////////////////////////////////////////////////////


proc skCheckSkeletonDef()
{
   // this function is called every time the UI is loaded, to make sure maya file has the right attributes created
   // (for backward compatibility).  But it doesn't modify attributes that already exist.

   // This creates a "SkelDef" node to store attributes about the skeleton

   global string $skVersion;

   if ( !`objExists SmartbodyExportOptions` )
   {
      group -empty -name "SmartbodyExportOptions";
      setAttr "SmartbodyExportOptions.visibility" 0;
   }

   if ( !`objExists SkelDef` )
   {
      group -empty -name "SkelDef" -parent SmartbodyExportOptions;
   }

   if ( !`objExists SkelDef.Version` )
   {
      addAttr -longName "Version" -dataType "string" SkelDef;
      setAttr -type "string" SkelDef.Version $skVersion;
   }

   if ( !`objExists SkelDef.RootJoint` )
   {
      addAttr -longName "RootJoint" -dataType "string" SkelDef;

      string $result = `promptDialog -title "Define New Skeleton" - message "Root Joint's Name?"
                       - button "OK" -button "Cancel" -defaultButton "OK" 
                       - cancelButton "Cancel" -dismissString "Cancel"`;

      if ( $result == "OK" )
      {
         $rootJointName = `promptDialog -query -text`;

         // Make sure rootJointName is valid
         if ( !`objExists $rootJointName` )
         {
            print( $rootJointName + " is an invalid name for the root joint\n" );
         }

         setAttr -type "string" SkelDef.RootJoint $rootJointName;
      }
   }

   if ( !`objExists SkelDef.SkeletonName` )
   {
      addAttr -longName "SkeletonName" -dataType "string" SkelDef;
      setAttr -type "string" SkelDef.SkeletonName "default";
   }

   if ( !`objExists SkelDef.OutputDirectory` )
   {
      addAttr -longName "OutputDirectory" -dataType "string" SkelDef;
      setAttr -type "string" SkelDef.OutputDirectory "./default.sk";
   }

   if ( !`objExists SkelDef.ShowAllChannels` )
   {
      addAttr -longName "ShowAllChannels" -attributeType bool SkelDef;
      setAttr SkelDef.ShowAllChannels false;
   }

   if ( !`objExists SkelDef.UseLimits` )
   {
      addAttr -longName "UseLimits" -attributeType bool SkelDef;
      setAttr SkelDef.UseLimits true;
   }

   if ( !`objExists SkelDef.UseChannelAttributes` )
   {
      addAttr -longName "UseChannelAttributes" -attributeType bool SkelDef;
      setAttr SkelDef.UseChannelAttributes false;
   }
}


global proc int skRootJointChanged()
{
   string $root = `textFieldGrp -q -text skRootField`;
   setAttr -type "string" SkelDef.RootJoint $root;
   return 1;
}


global proc int skNameChanged()
{
   string $name = `textFieldGrp -q -text skOutputName`;

   string $filepath = `textFieldGrp -q -text skOutputFile`;
   textFieldGrp -e -text ( `dirname($filepath)` + "/" + $name + ".sk" ) skOutputFile;

   setAttr -type "string" SkelDef.SkeletonName $name;


   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;

   return 1;
}


global proc int skOutputDirChanged()
{
   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;
   return 1;
}


global proc int skFileCb( string $filename, string $fileType )
{
   //--- here, get the relative path
   string $absPath = $filename;
   string $refPath = `workspace -en ""`;
   
   string $finalDir = substituteAllString($absPath, $refPath, "");
   if ($finalDir == $absPath)
     textFieldGrp -e -text ($filename+"/"+`textFieldGrp -q -text skOutputName`+".sk") skOutputFile; 
   else
     textFieldGrp -e -text ($finalDir+"/"+`textFieldGrp -q -text skOutputName`+".sk") skOutputFile;   
   
   skOutputDirChanged();
   return 1;
}


global proc ChannelsChecked()
{
   setAttr SkelDef.ShowAllChannels true;
}


global proc ChannelsUnchecked()
{
   setAttr SkelDef.ShowAllChannels false;
}


global proc LimitsChecked()
{
   setAttr SkelDef.UseLimits true;
}


global proc LimitsUnchecked()
{
   setAttr SkelDef.UseLimits false;
}


global proc UseChannelAttributesChecked()
{
   setAttr SkelDef.UseChannelAttributes true;
}


global proc UseChannelAttributesUnchecked()
{
   setAttr SkelDef.UseChannelAttributes false;
}

proc updateChannelAttributes(string $jointName)
{
	int $i;
	for ($i = 0; $i < 4; $i++)
	{
		if ($i == 0) $attribute = $jointName + ".SbodyPosX";
		if ($i == 1) $attribute = $jointName + ".SbodyPosY";
		if ($i == 2) $attribute = $jointName + ".SbodyPosZ";
		if ($i == 3) $attribute = $jointName + ".SbodyQuat";
		
		string $checkBoxName = substituteAllString($attribute, ".", "");
		if (`checkBox -q -exists $checkBoxName`)
		{
			if ( `objExists $attribute` )  
			{
			  int $val = `checkBox -q -value $checkBoxName`;
			  setAttr $attribute $val;
			}
			else
			{
		      int $val = `checkBox -q -value $checkBoxName`;
			  if ($val == 1)
			  {
				string $tokens[];
				int $numToken = `tokenize $attribute "." $tokens`;
				if ($numToken == 2)
				{
					addAttr -longName $tokens[1] -attributeType bool -defaultValue 0 $tokens[0];
					setAttr $attribute 1;
				}
			   }
			}
		}
		else
		{
		  print ($attribute + " Not Exist!\n");
		}
	}
	string $Children[] = `listRelatives $jointName`;	
	for ($i = 0; $i < size($Children); $i = $i + 1)
	{
	  string $type = nodeType($Children[$i]);
	  if ($type != "joint")  continue;
	  updateChannelAttributes($Children[$i]);
	}	  	
}


global proc updateUseChannelAttributes()
{
	string $root = `getAttr SkelDef.RootJoint`;
	//recursively update channel attribute here
	updateChannelAttributes($root);		
}

global proc printJointChannel(int $useChannelAttributes, string $jointName, int $counter)
{
	global int $isFacial;
	int $i;
	rowColumnLayout -numberOfRows 1 -rowHeight 1 20 -rowSpacing 1 2 -columnAttach 1 "right" 3;
	string $displayJointName;
	if ($counter > 0)
	{
		for ($i = 0; $i < $counter; $i = $i + 1)
			$displayJointName = $displayJointName + "  ";
	}
	$displayJointName = $displayJointName + " * " + $jointName + "  ";
	text -label $displayJointName;
	
	if ($useChannelAttributes)
	{
	  int $channelAttributePosX = 0;
	  int $channelAttributePosY = 0;
	  int $channelAttributePosZ = 0;
	  int $channelAttributeQuat = 0;

	  if ( `objExists ( $jointName + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $jointName + ".SbodyPosX" )`;
	  if ( `objExists ( $jointName + ".SbodyPosY" )` )  $channelAttributePosY = `getAttr ( $jointName + ".SbodyPosY" )`;
	  if ( `objExists ( $jointName + ".SbodyPosZ" )` )  $channelAttributePosZ = `getAttr ( $jointName + ".SbodyPosZ" )`;
	  if ( `objExists ( $jointName + ".SbodyQuat" )` )  $channelAttributeQuat = `getAttr ( $jointName + ".SbodyQuat" )`;
	  
	  checkBox -label "XPos" -value $channelAttributePosX -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosX");
	  checkBox -label "YPos" -value $channelAttributePosY -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosY");
	  checkBox -label "ZPos" -value $channelAttributePosZ -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosZ");
	  checkBox -label "Quat" -value $channelAttributeQuat -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyQuat");
	}
	$counter = $counter + 1;
	string $Children[] = `listRelatives $jointName`;
	setParent ..;		
	for ($i = 0; $i < size($Children); $i = $i + 1)
	{
		string $type = nodeType($Children[$i]);
		if ($type != "joint")  continue;
		printJointChannel($useChannelAttributes, $Children[$i], $counter);
	}
	$counter = $counter - 1;	
}

global proc showExportingChannelsWin()
{
	if ((`window -exists showExportingChannelsWin`) == true)
	{
		deleteUI showExportingChannelsWin;
		windowPref -remove showExportingChannelsWin;
	}

	// create UI Window here
	window -title ("Exporting Channels Manager") -resizeToFitChildren true -sizeable true -width 600 -height 800 showExportingChannelsWin;
	// display here
	string $root = `getAttr SkelDef.RootJoint`;
	int $useChannelAttributes = `getAttr SkelDef.UseChannelAttributes`;

	// recursive print tree visualization
	int $counter  = 0;
	scrollLayout;
	columnLayout -adjustableColumn true -columnAttach "both" 5;
	printJointChannel($useChannelAttributes, $root, $counter);	   

	showWindow showExportingChannelsWin;
}

global proc skExportButton()
{
   string $file = `getAttr SkelDef.OutputDirectory`;
  // resolve file path according to project root directory
   string $projectRoot = `workspace -en ""`;
   $file = substituteAllString($file, "\\", "/");   
   string $afterSubstitute = substituteAllString($file, "//", "*");  
   if ($afterSubstitute == $file)
   {
     string $absoluteFile = substituteAllString($file, ":", "");
	 if ($absoluteFile == $file)  $file = $projectRoot + $file;
   }
   else
   {
     if ($afterSubstitute != $file)
	 {
       string $tokens[];
       int $numTokens = `tokenize $afterSubstitute "*" $tokens`;
	   $file = $projectRoot + $tokens[$numTokens - 1];
	 }
   }
   $file = `workspace -en $file`;      
   skExport( $file );
}


global proc skExportGUI()
{
   global string $skVersion;


   // check to make sure Smartbody nodes exist
   skCheckSkeletonDef();


   // Build UI
   if ( ( `window -exists skMainWin` ) == true )
      deleteUI skMainWin;

   string $winTitle = "SK Exporter v" + $skVersion;
   window -title $winTitle -wh 300 290 skMainWin;
   columnLayout -adjustableColumn true -columnAttach "both" 10 -rowSpacing 10 -columnWidth 290 MainColumn;
   textFieldGrp -label "Skeleton Root Joint:" -text `getAttr SkelDef.RootJoint` -changeCommand "skRootJointChanged" skRootField;
   textFieldGrp -label "Output Character Name:" -text `getAttr SkelDef.SkeletonName` -changeCommand "skNameChanged" skOutputName;
   textFieldGrp -label "Output File:" -text `getAttr SkelDef.OutputDirectory` -changeCommand "skOutputDirChanged" skOutputFile;
   setParent MainColumn;
   columnLayout -columnAttach "left" 85 -columnWidth 300 - rowSpacing 5 CBRow2;
   setParent CBRow2;
   checkBox -label "Use Channel Attributes" -value (`getAttr SkelDef.UseChannelAttributes`) -onCommand "UseChannelAttributesChecked" -offCommand "UseChannelAttributesUnchecked" skUseChannelAttributes;
   checkBox -label "Export All Channels" -value (`getAttr SkelDef.ShowAllChannels`) -onCommand "ChannelsChecked" -offCommand "ChannelsUnchecked" skShowAllChannels;
   checkBox -label "Export Limits" -value (`getAttr SkelDef.UseLimits`) -onCommand "LimitsChecked" -offCommand "LimitsUnchecked" skUseLimits;
   setParent MainColumn;
   button -label "Show Exporting Channels" -command showExportingChannelsWin;
   button -label "Browse Output File" -command "fileBrowser(\"skFileCb\", \"Text\", \"\", 4)";   
   button -label "Export" -command "skExportButton";
   showWindow skMainWin; 
}
