//  export_sk.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Andrew n marshall, USC
//      Kristin Parker, USC


// - All joints are exported with quaternion rotation channel
// - Only base joint is exported with translation channels
// - If "Mirror Joint" is used to create the skeleton in Maya, be sure to use the
//   "orientation" option (not "behavior")


string $skVersion = "0.5";


// --------------------------------------------------------------------------------
// PROC: skRound
// This will round a number to a certain precision, the bulk of this script actually deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if ( `substring $valueString 1 1` == "-" )
   {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ( $value * $multiplyer ) ;
   $value = ( $value + 0.5 ) ;
   $value = `trunc $value` ;
   
   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;

   //print ( $value + "\n" ) ;
   //print ( "StringSize: " + $StringSize + "\n" ) ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ( $StringSize <= 5 )
   {
      $SmallValues = 1 ;

      int $dif = ( 5 - $StringSize ) ;
      if ( $dif == 4 )
      {
         $zeroes = "0000" ;
      }
      else if ( $dif == 3 )
      {
         $zeroes = "000" ;
      }
      else if ( $dif == 2 )
      {
         $zeroes = "00" ;
      }
      else if ( $dif == 1 )
      {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ( $zeroes + $valueString ) ;

      //print ( $valueString + "\n" ) ;
   }

   //Assemble new strings
   if ( $SmallValues == 1 )
   {
      $wholeNumber = "0" ;
   }
   else
   {
      $wholeNumber = `substring $valueString 1 ( $StringSize - $precision )` ;
   }

   $decNumber = `substring $valueString ( $StringSize - ( $precision - 1 ) ) ( $StringSize )` ;  //this seems unneccesarry

   $valueString = ( $sign + $wholeNumber + "." + $decNumber ) ;

   return $valueString ;
}


proc int skMargin( int $fileid, int $depth )
{
   for ( $k = 0; $k < $depth; $k++ )
      fprint $fileid ("  ");

   return 1;
}


proc int skWriteSk( string $jname, int $fileid, int $depth, int $showAll, int $useLimits, int $useChannelAttributes )
{
   // RECURSIVE function


   //=== Get Children ===
   string $children[];
   $children = `listRelatives $jname`;
   int $nchildren = `size $children`;


   string $type = nodeType( $jname );


   // Write info for visible geometry meshes
   if ( $type == "mesh" )
   {
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "visgeo \"" + $jname + ".obj\"\r\n" );
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "colgeo \"" + $jname + ".obj\"\r\n" );
   }


   // If object is not of type "joint" then recurse
   // HACK - initial_base is of type "transform", but we want to include it and not skip it.
   if ( $type != "joint" && $jname != "initial_base" )
   {
      if ( $type != "mesh" )
      {
         print( "Skipping " + $jname + ": " + $type + "\n" );
      }

      for ( $i = 0; $i < $nchildren; $i++ )
      {
         skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits, $useChannelAttributes );
      }

      return 1;
   }


   //=== Export Joint ===
   print( "Exporting joint " + $jname + "\n" );

   // Check if this is the root node of the hierarchy
   if ( $depth == 0 )
   {
      skMargin( $fileid, $depth );
      fprint $fileid ( "root " );
   }
   else
   {
      fprint $fileid ( "\r\n" );
      skMargin( $fileid, $depth );
      fprint $fileid ( "joint " );
   }

   fprint $fileid ( $jname + "\r\n" );


   //Get and then write translation offsets
   float $offset[ 3 ];
   $offset[ 0 ] = `getAttr ( $jname + ".translateX" )`;
   $offset[ 1 ] = `getAttr ( $jname + ".translateY" )`;
   $offset[ 2 ] = `getAttr ( $jname + ".translateZ" )`;

   skMargin ( $fileid, $depth );
   fprint $fileid ( "{\r\n" );
   skMargin ( $fileid, $depth + 1 );
   fprint $fileid ( "offset " );
   fprint $fileid ( skRound( $offset[ 0 ] ) + " " + skRound( $offset[ 1 ] ) + " " + skRound( $offset[ 2 ] ) + "\r\n" );


   // Write translation channels and limits

   $channelAttributePosX = 0;
   $channelAttributePosY = 0;
   $channelAttributePosZ = 0;
   $channelAttributeQuat = 0;

   if ( $useChannelAttributes )
   {
      if ( `objExists ( $jname + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $jname + ".SbodyPosX" )`;
      if ( `objExists ( $jname + ".SbodyPosX" )` )  $channelAttributePosY = `getAttr ( $jname + ".SbodyPosY" )`;
      if ( `objExists ( $jname + ".SbodyPosX" )` )  $channelAttributePosZ = `getAttr ( $jname + ".SbodyPosZ" )`;
      if ( `objExists ( $jname + ".SbodyPosX" )` )  $channelAttributeQuat = `getAttr ( $jname + ".SbodyQuat" )`;
   }


   int $mntmn[] = ( `transformLimits -query -etx $jname` );
   float $xTransLimitValues[] = ( `transformLimits -query -tx $jname` );
   float $yTransLimitValues[] = ( `transformLimits -query -ty $jname` );
   float $zTransLimitValues[] = ( `transformLimits -query -tz $jname` );

   if ( $mntmn[ 0 ] && $mntmn[ 1 ] )
   {
      // limits exist
      if ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0" + " lim " + $xTransLimitValues[ 0 ] + " " + $xTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
      }

      if ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0" + " lim " + $yTransLimitValues[ 0 ] + " " + $yTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
      }

      if ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0" + " lim " + $zTransLimitValues[ 0 ] + " " + $zTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
   }
   else
   {
      if ( $useChannelAttributes )
      {
         if ( $channelAttributePosX )
         {
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel XPos 0 free\r\n" );
         }
         if ( $channelAttributePosY )
         {
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel YPos 0 free\r\n" );
         }
         if ( $channelAttributePosZ )
         {
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel ZPos 0 free\r\n" );
         }
      }
      else
      {
         if ( $showAll )
         {
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel XPos 0 free\r\n" );
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel YPos 0 free\r\n" );
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel ZPos 0 free\r\n" );
         }
         else if ( $jname == "base" )
         {
            // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis
   
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel XPos 0 free\r\n" );
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel YPos 0 free\r\n" );
            skMargin( $fileid, $depth + 1 );
            fprint $fileid ( "channel ZPos 0 free\r\n" );
         }
      }
   }


   // Write rotation channel
   if ( $useChannelAttributes )
   {
      if ( $channelAttributeQuat )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel Quat\r\n" );
      }
   }
   else
   {
      skMargin( $fileid, $depth + 1 );
      fprint $fileid ( "channel Quat\r\n" );
   }


   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits, $useChannelAttributes );
   }


   //=== End ===
   skMargin( $fileid, $depth );
   fprint $fileid ( "}\r\n" );

   return 1;
}


global proc int skExport( string $fname )
{
   // main entry point for exporting .sk file.
   // if you want to specify your own file name and location for .sk, then call this function.
   // to pull the file name from maya file, then call skExportButton()

   global string $skVersion;

   string $root   = `getAttr SkelDef.RootJoint`;
   string $skName = `getAttr SkelDef.SkeletonName`;
   int $showAll   = `getAttr SkelDef.ShowAllChannels`;
   int $useLimits = `getAttr SkelDef.UseLimits`;
   int $useChannelAttributes = `getAttr SkelDef.UseChannelAttributes`;

   select -r $root;


   print( "skExport() - $fname=" + $fname + " $skName=" + $skName + " $skVersion=" + $skVersion + " $showAll=" + $showAll + " $useLimits=" + $useLimits + " $useChannelAttributes=" + $useChannelAttributes + "\n" );


   int $fileid = `fopen $fname "w"`;
   if ( $fileid == 0 )
   {
      error( "Could not open file: " + $fname );
      return 0;
   }

   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected!\n";
   }

   int $selectionListSize = `size $selectionList`;
   int $depth = 0;

   // EDF - This loop seems intended for multiple characters, or in the instance where multiple objects may be in the scene besides the character
   //       These cases haven't been tested, and probably will not produce correct results.  Watch out for this loop.
   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      print ( "----------SK Export Report----------\n" );

      fprint $fileid ( "# SK Skeleton Definition\r\n" );
      fprint $fileid ( "# File generated with export_sk.mel v" + $skVersion + "\r\n\r\n" );
      fprint $fileid ( "set_name " + $skName + "\r\n\r\n" );
      fprint $fileid ( "skeleton\r\n" );

      skWriteSk( $selectionList[ $j ], $fileid, $depth, $showAll, $useLimits, $useChannelAttributes );

      fprint $fileid ( "\r\n" );
      fprint $fileid ( "end\r\n" );
   }

   fclose( $fileid );
   print( "Export done.\n" );
   return 1;
}






////////////////////////////////////////////////////////////////
//  GUI CODE
////////////////////////////////////////////////////////////////


proc skAddSkeletonDef()
{
   // This creates a "SkelDef" node to store various attributes about the skeleton

   string $result = `promptDialog -title "Define New Skeleton" - message "Root Joint's Name?"
               - button "OK" -button "Cancel" -defaultButton "OK" 
               - cancelButton "Cancel" -dismissString "Cancel"`;

   if ( $result == "OK" )
   {
      $rootJointName = `promptDialog -query -text`;

      // Make sure rootJointName is valid
      if ( `objExists $rootJointName` )
      {
         // Valid joint entered
         group -n "SkelDef" -em -p SmartbodyExportOptions ;

         addAttr -ln "RootJoint" -dt "string" SkelDef ;
         setAttr -type "string" SkelDef.RootJoint $rootJointName;

         addAttr -ln "SkeletonName" -dt "string" SkelDef;
         setAttr -type "string" SkelDef.SkeletonName "default";

         addAttr -ln "OutputDirectory" -dt "string" SkelDef;
         setAttr -type "string" SkelDef.OutputDirectory "./default.sk";

         addAttr -ln "ShowAllChannels" -at bool SkelDef;
         setAttr SkelDef.ShowAllChannels false;

         addAttr -ln "UseLimits" -at bool SkelDef;
         setAttr SkelDef.UseLimits true;

         addAttr -ln "UseChannelAttributes" -at bool SkelDef;
         setAttr SkelDef.UseChannelAttributes false;
      }
      else
      {
         string $errorMsg = $rootJointName + " is an invalid name for the root joint. Script has exited.\n ";
         error( $errorMsg );
      }
   }
}


proc int skRootJointChanged()
{
   string $root = `textFieldGrp -q -text skRootField`;
   setAttr -type "string" SkelDef.RootJoint $root;
   return 1;
}


proc int skNameChanged()
{
   string $name = `textFieldGrp -q -text skOutputName`;

   string $filepath = `textFieldGrp -q -text skOutputFile`;
   textFieldGrp -e -text ( `dirname($filepath)` + "/" + $name + ".sk" ) skOutputFile;

   setAttr -type "string" SkelDef.SkeletonName $name;


   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;

   return 1;
}


proc int skOutputDirChanged()
{
   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;
   return 1;
}


proc int skFileCb( string $filename, string $fileType )
{
   textFieldGrp -e -text ($filename+"/"+`textFieldGrp -q -text skOutputName`+".sk") skOutputFile;
   return 1;
}


proc ChannelsChecked()
{
   setAttr SkelDef.ShowAllChannels true;
}


proc ChannelsUnchecked()
{
   setAttr SkelDef.ShowAllChannels false;
}


proc LimitsChecked()
{
   setAttr SkelDef.UseLimits true;
}


proc LimitsUnchecked()
{
   setAttr SkelDef.UseLimits false;
}


proc UseChannelAttributesChecked()
{
   setAttr SkelDef.UseChannelAttributes true;
}


proc UseChannelAttributesUnchecked()
{
   setAttr SkelDef.UseChannelAttributes false;
}


global proc skExportButton()
{
   string $file = `getAttr SkelDef.OutputDirectory`;
   skExport( $file );
}


global proc skExportGUI()
{
   global string $skVersion;

   // Creates SmartbodyExportOptions and SkelDef nodes if they don't exist
   if ( !`objExists SmartbodyExportOptions` )
   {
      // SmartbodyExportOptions needs to be created
      group -empty -name "SmartbodyExportOptions";
      setAttr "SmartbodyExportOptions.visibility" 0;
      skAddSkeletonDef();
   }
   else
   {
      if ( !`objExists SkelDef` )
      {
         // Skeleton definition has not been made yet
         skAddSkeletonDef();
      }
   }

   // Build UI
   if ( ( `window -exists skMainWin` ) == true )
      deleteUI skMainWin;

   string $winTitle = "SK Exporter v" + $skVersion;
   window -title $winTitle -wh 300 270 skMainWin;
   columnLayout -adjustableColumn true -columnAttach "both" 10 -rowSpacing 10 -columnWidth 290 MainColumn;
   textFieldGrp -label "Skeleton Root Joint:" -text `getAttr SkelDef.RootJoint` -cc "skRootJointChanged" skRootField;
   textFieldGrp -label "Output Character Name:" -text `getAttr SkelDef.SkeletonName` -cc "skNameChanged" skOutputName;
   textFieldGrp -label "Output File:" -text `getAttr SkelDef.OutputDirectory` -cc "skOutputDirChanged" skOutputFile;
   setParent MainColumn;
   columnLayout -columnAttach "left" 85 -columnWidth 300 - rowSpacing 5 CBRow2;
   setParent CBRow2;
   checkBox -label "Use Channel Attributes" -value (`getAttr SkelDef.UseChannelAttributes`) -onCommand "UseChannelAttributesChecked" -offCommand "UseChannelAttributesUnchecked" skUseChannelAttributes;
   checkBox -label "Export All Channels" -value (`getAttr SkelDef.ShowAllChannels`) -onCommand "ChannelsChecked" -offCommand "ChannelsUnchecked" skShowAllChannels;
   checkBox -label "Export Limits" -value (`getAttr SkelDef.UseLimits`) -onCommand "LimitsChecked" -offCommand "LimitsUnchecked" skUseLimits;
   setParent MainColumn;
   button -l "Browse Output File" -command "fileBrowser(\"skFileCb\", \"Text\", \"\", 4)";
   button -l "Export" -command "skExportButton";
   showWindow skMainWin; 
}
