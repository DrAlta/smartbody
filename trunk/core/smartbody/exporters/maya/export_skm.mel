//  export_skm.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Andrew n marshall, USC



////////////////////////////////////////////////////////////////
//  Exports animation in .skm format for SmartBody
//  Prompts for BML timing metadata


string $skmVersion = "1.1";
int $isFacial = 0;
int $partialExportToggle = 0;

global string $g_names[];
global int    $g_namesWidth;

//docServer(1);
updateRendererUI;


// --------------------------------------------------------------------------------
// PROC: skmRound
// This will round a number to a certain precision, the bulk of this script actually deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skmRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if ( `substring $valueString 1 1` == "-" )
   {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ( $value * $multiplyer ) ;
   $value = ( $value + 0.5 ) ;
   $value = `trunc $value` ;

   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;

   //print ( $value + "\n" ) ;
   //print ( "StringSize: " + $StringSize + "\n" ) ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ( $StringSize <= 5 )
   {
      $SmallValues = 1 ;

      int $dif = ( 5 - $StringSize ) ;
      if ( $dif == 4 )
      {
         $zeroes = "0000" ;
      }
      else if ( $dif == 3 )
      {
         $zeroes = "000" ;
      }
      else if ( $dif == 2 )
      {
         $zeroes = "00" ;
      }
      else if ( $dif == 1 )
      {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ( $zeroes + $valueString ) ;

      //print ( $valueString + "\n" ) ;
   }

   //Assemble new strings
   if ( $SmallValues == 1 )
   {
      $wholeNumber = "0" ;
   }
   else
   {
      $wholeNumber = `substring $valueString 1 ( $StringSize - $precision )` ;
   }

   $decNumber = `substring $valueString ( $StringSize - ( $precision - 1 ) ) ( $StringSize )` ;  //this seems unneccesarry

   $valueString = ( $sign + $wholeNumber + "." + $decNumber ) ;

   return $valueString ;
}


// procedures for emulating a 2d array, of a known width
proc string Get2dArrayString( string $s[], int $width, int $x, int $y )
{
   return $s[ ( $x * $width ) + $y ];
}


// procedures for emulating a 2d array, of a known width
proc Set2dArrayString( string $s[], int $width, int $x, int $y, string $value )
{
   $s[ ( $x * $width ) + $y ] = $value;
}


// make a quaternion from the given rotation around axis (x,y,z)
proc skmQuatSet( float $q[], float $x, float $y, float $z, float $degrees )
{
   float $f;
   float $radians = 3.1415926535897932 * $degrees / 180.0;

   // normalize axis:
   $q[ 1 ] = $x;
   $q[ 2 ] = $y;
   $q[ 3 ] = $z;

   $f = $x * $x + $y * $y + $z * $z;

   if ( $f > 0 )
   {
      $f = sqrt( $f );
      $q[ 1 ] /= $f;
      $q[ 2 ] /= $f;
      $q[ 3 ] /= $f;
   }

   // set the quaternion:
   $radians /= 2;
   $f = sin( $radians );
   $q[ 1 ] *= $f;
   $q[ 2 ] *= $f;
   $q[ 3 ] *= $f;
   $q[ 0 ] = cos( $radians );
}


// quaternion multiplication
proc skmQuatMult( float $q[], float $q1[], float $q2[] )
{
   $q[ 0 ] = ( $q1[ 0 ] * $q2[ 0 ] ) - ( $q1[ 1 ] * $q2[ 1 ] + $q1[ 2 ] * $q2[ 2 ] + $q1[ 3 ] * $q2[ 3 ] ); // w1*w2-dot(v1,v2)
   $q[ 1 ] = $q1[ 2 ] * $q2[ 3 ] - $q1[ 3 ] * $q2[ 2 ]; // cross ($q1.v,$q2.v)
   $q[ 2 ] = $q1[ 3 ] * $q2[ 1 ] - $q1[ 1 ] * $q2[ 3 ];
   $q[ 3 ] = $q1[ 1 ] * $q2[ 2 ] - $q1[ 2 ] * $q2[ 1 ];
   $q[ 1 ] += ( $q1[ 1 ] * $q2[ 0 ] ) + ( $q2[ 1 ] * $q1[ 0 ] );
   $q[ 2 ] += ( $q1[ 2 ] * $q2[ 0 ] ) + ( $q2[ 2 ] * $q1[ 0 ] );
   $q[ 3 ] += ( $q1[ 3 ] * $q2[ 0 ] ) + ( $q2[ 3 ] * $q1[ 0 ] );
 }


// quaternion to axis-angle representation
proc quatToAxisAng( float $q[], float $aa[] )
{
   float $ang = 2.0 * acos( $q[ 0 ] );
   float $norm = sqrt( $q[ 1 ] * $q[ 1 ] + $q[ 2 ] * $q[ 2 ] + $q[ 3 ] * $q[ 3 ] );
   if ( $norm == 0 || $ang == 0 )
   {
      $aa[ 0 ] = 0;
      $aa[ 1 ] = 0;
      $aa[ 2 ] = 0;
   }
   else
   {
      $aa[ 0 ] = ( $q[ 1 ] / $norm ) * $ang;
      $aa[ 1 ] = ( $q[ 2 ] / $norm ) * $ang;
      $aa[ 2 ] = ( $q[ 3 ] / $norm ) * $ang;
    }
}


// returns the index of the name containing $type, however
// $type is assumed to be at the end of each name
// (types are retrieved with: $names = `keyframe -q -name pinky3_l`;)
proc int skmSearchType( string $names[], string $type )
{
   string $subst;
   int $size = size( $names );
   int $sizet = size( $type );
   int $sizei;
   int $i;
   int $cmp;

   for ( $i = 0; $i < $size; $i++ )
   {
      $sizei = size( $names[ $i ] );
      $subst = `substring $names[ $i ] ( $sizei - $sizet + 1 ) $sizei`;
      $cmp = `strcmp $subst $type`;
      if ( $cmp == 0 )
         return $i;
    }

   return -1;
}

proc int skmCountJoints( string $jname, string $joints[] )
{
   // Get children of $jname
   string $children[];
   $children = `listRelatives $jname`;
   int $nchildren = `size $children`;

   // Make sure $jname is a joint
   string $type = nodeType( $jname );
   if ( $type != "joint" )
   {
      return 0;
   }

   //=== Check if there are keys ===
   int $n = 1; // will remain 1 if joint is to be counted, 0 otherwise
   string $jnames[];
   $jnames = `keyframe -q -name $jname`;

   if ( size( $jnames ) == 0 )
      $n = 0; // no info

   if ( skmSearchType( $jnames, "ateX") == -1 &&
        skmSearchType( $jnames, "ateY") == -1 &&
        skmSearchType( $jnames, "ateZ") == -1 )
   {
      $n = 0; // no rotate or translate
   }

   //=== Count this joint if n is 1 ===
   global int $curJointsId;
   if ( $n == 1 )
   {
      $joints[ $curJointsId ] = $jname;
      $curJointsId = $curJointsId + 1;
   }

   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      $n = $n + skmCountJoints( $children[ $i ], $joints );
   }
   
   return $n;
}


//to get key index:     keyframe -eval -index $key  -query $queryName
//to evaluate at frame: keyframe -eval -time $frame -query $queryName
proc float skmKeyVal( int $frame, string $queryName )
{
   float $val[];
   global int $isFacial;

   // if there is no key we search the 1st prior valid key for the joint
   while ( size( $val ) == 0 )
   {
      // Make sure frame won't be negative
      if ( ( $frame < 0 ) && ( $isFacial == 0 ) )
         $frame = 0;

      $val = `keyframe -eval -time $frame -query $queryName`;
            
      // Make sure frame 0 always have a valid key
      if ( ($frame == 0) && (size($val)==0) )
         return 0;
      $frame = $frame - 1;
   }

   return $val[ 0 ];
}

// $flag here indicates whether to zero out the channel
proc skmCheckAndWriteKey( int $fileid, string $names[], string $type, int $frame, int $flag )
{
   global int $isFacial;
   float $base;

   int $id = skmSearchType( $names, $type );

   if ( $isFacial )
   {
      $base = skmKeyVal( 0, $names[ $id ] );
   }

   if ( $id >= 0 )
   {
      float $val = skmKeyVal( $frame, $names[ $id ] );

      if ( $isFacial )
      {
         $val = $val - $base;  // Subtract value at reference frame
      }

      if( $flag != 0 )
         fprint $fileid ( " " + skmRound( $val ) );
      if( $flag == 0)
         fprint $fileid ( " " + 0 );
   }
}

// $flag here indicates whether to zero out the channel
proc skmCheckAndWriteKeyQuat( int $fileid, string $names[], int $frame, int $flag )
{
   int $idx = skmSearchType( $names, "rotateX" );
   int $idy = skmSearchType( $names, "rotateY" );
   int $idz = skmSearchType( $names, "rotateZ" );
   if ( $idx < 0 && $idy < 0 && $idz < 0 )
      return;

   float $xa = 0;
   float $ya = 0;
   float $za = 0;
   if ( $idx >= 0 ) $xa = skmKeyVal( $frame, $names[ $idx ] );
   if ( $idy >= 0 ) $ya = skmKeyVal( $frame, $names[ $idy ] );
   if ( $idz >= 0 ) $za = skmKeyVal( $frame, $names[ $idz ] );

   float $qx[];
   float $qy[];
   float $qz[];
   skmQuatSet( $qx, 1, 0, 0, $xa );
   skmQuatSet( $qy, 0, 1, 0, $ya );
   skmQuatSet( $qz, 0, 0, 1, $za );

   // compose to zyx instead of xyz due to the used column-major matrix format
   float $qzyx[];
   float $qyx[];
   float $aa[];
   skmQuatMult( $qyx, $qy, $qx );
   skmQuatMult( $qzyx, $qz, $qyx );
   quatToAxisAng( $qzyx, $aa );
   if( $flag != 0 )
      fprint $fileid ( " " + skmRound( $aa[ 0 ] ) + " " + skmRound( $aa[ 1 ] ) + " " + skmRound( $aa[ 2 ] ) );
   if( $flag == 0 )
      fprint $fileid ( " " + 0 + " " + 0 + " " + 0 );   
}

// $flag here indicates whether to zero out the channel, used for partial animation export
proc skmWriteKeyData( int $fileid, int $frame, string $jointName, int $jid, int $partialFlag )
{
   global string $g_names[];
   global int $g_namesWidth;
   global int $isFacial;

   string $names[];
   float $val[];
   int $i;
   int $trstart = 0;

   // get used rotations/translations in the joint:
   //$names = `keyframe -q -name $jointName`;

   // the line above was too slow to be called per joint, per frame.
   // we stored the array in a 2d array at the beginning.  Now copy the
   // portion we're interested in to a single array
   for ( $i = 0; $i < $g_namesWidth; $i++ )
   {
      string $s = Get2dArrayString( $g_names, $g_namesWidth, $jid, $i );
      if ( $s == "" )
         break;

      $names[ $i ] = $s;
   }


   // Note: "keyframe -q -name  base;" returns:
   //       "base_translateZ base_translateX base_translateY base_rotateX base_rotateY base_rotateZ"
 
   if( $partialFlag == 0 )  $flag = 0;
   else                     $flag = 1;
   if ( ( $jid == 0 ) || ( $isFacial ) ) // send translation only for root
   {
      skmCheckAndWriteKey( $fileid, $names, "translateX", $frame, $flag );
      skmCheckAndWriteKey( $fileid, $names, "translateY", $frame, $flag );
      skmCheckAndWriteKey( $fileid, $names, "translateZ", $frame, $flag );
   }

   skmCheckAndWriteKeyQuat( $fileid, $names, $frame, $flag );
}


proc skmCheckAndWrite( int $fileid, string $names[], string $type, string $joint, string $skmtype )
{
   int $id = skmSearchType( $names, $type );
   if ( $id >= 0 )
      fprint $fileid ( $joint + $skmtype );
}


proc skmCheckAndWriteQuat( int $fileid, string $names[], string $joint )
{
   int $idx = skmSearchType( $names, "rotateX" );
   int $idy = skmSearchType( $names, "rotateY" );
   int $idz = skmSearchType( $names, "rotateZ" );
   if ( $idx >= 0 || $idy >= 0 || $idz >= 0 )
      fprint $fileid ( $joint + " Quat\n" );
}


proc skmWriteSkm( int $startFrame, int $endFrame, string $joints[], int $fileid, int $fps )
{
   global int $isFacial;

   global string $g_names[];
   global int $g_namesWidth;

   // Export translations and/or Quat rotations:
   global int $curJointsId;

   string $names[];

   // find max width of names array so we can store in a hacked 2d array
   $g_namesWidth = 0;
   for ( $i = 0; $i < $curJointsId; $i++ )
   {
      $names = `keyframe -q -name $joints[ $i ]`;
      if ( size( $names ) > $g_namesWidth )
      {
         $g_namesWidth = size( $names );
      }
   }

   for ( $i = 0; $i < $curJointsId; $i++ )
   {
      $names = `keyframe -q -name $joints[ $i ]`;

      // store our hacked 2d array for use later
      for ( $n = 0; $n < size( $names ); $n++ )
      {
         Set2dArrayString( $g_names, $g_namesWidth, $i, $n, $names[ $n ] );
      }

      if ( ( $i == 0 ) || ($isFacial) ) // translation allowed only in root
      {
         skmCheckAndWrite( $fileid, $names, "translateX", $joints[ $i ], " XPos\n" );
         skmCheckAndWrite( $fileid, $names, "translateY", $joints[ $i ], " YPos\n" );
         skmCheckAndWrite( $fileid, $names, "translateZ", $joints[ $i ], " ZPos\n" );
      }

      skmCheckAndWriteQuat( $fileid, $names, $joints[ $i ] );
   }

   // frames:
   float $kt = 0;
   float $vec[];
   float $ktstep = 1.0 / $fps;

   if ( $startFrame > $endFrame )
      $startFrame = $endFrame;

   fprint $fileid ( "\nframes " + ( $endFrame - $startFrame + 1 ) + "\n" );

//$startTime1 = `timerX`;

   string $pjname = `textFieldGrp -q -text skmPartialExportJointField`;
   string $pjchildren[] = `ls -dag $pjname`;
   int $pjchildrennum = size( $pjchildren );

   for ( $f = $startFrame; $f <= $endFrame; $f++ )
   {
      print( "Writing frame " + $f +"/"+ $endFrame + "...\n" );

      fprint $fileid ( "kt " + $kt + " fr" );
    
      int $partialFlag = 0;
      int $partialCount = 0;
      for ( $i = 0; $i < $curJointsId; $i++ )
      {
         if( $pjname == $joints[ $i ] )
            $partialFlag = 1;
         if( $partialFlag != 0 )  $partialCount ++;
         skmWriteKeyData( $fileid, $f, $joints[ $i ], $i , $partialFlag);
         if( $partialCount >= $pjchildrennum )   $partialFlag = 0;
      }

      $kt += $ktstep;

      fprint $fileid ( "\n" );
   }

//$endTime1 = `timerX -st $startTime1`;
//print ( "TIME: skmWriteKeyData: " + $endTime1 + "\n" );
}


global proc int skmExport( string $fname,
                           string $AnimDef,
                           int $startFrame,
                           int $endFrame,
                           int $fps,
                           string $version )
{
   int $fileid = `fopen $fname "w"`;
   global int $isFacial;

   string $AnimName = basename( $fname, ".skm" );

   // Close file if nothing exists in scene    <-Is this really needed? -Matt
   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected! \n";
   }
   int $selectionListSize = `size $selectionList`;
   int $depth = 0;
   int $njoints;
   int $nchannels;
   string $joints[]; // array to be filled with all joints names
   global int $curJointsId = 0; // start filling at position 0 (root is at pos 0)

   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      $curJointsId = 0;

      //Print basic file information
      fprint $fileid ( "# SKM Motion Definition \n" );
      fprint $fileid ( "# Maya Exporter v" + $version + "\n\n" );
      fprint $fileid ( "SkMotion\n\n" );
      fprint $fileid ( "name \"" + $AnimName + "\"\n\n" );

      $njoints = skmCountJoints( $selectionList[ $j ], $joints);
      
      print( "Joints found:\n" );
      print $joints;
      print( "\n" );

      //Give Error if NO key attributes found, which means the animation is not properly baked or maybe anim layer problem
      if( $njoints == 0 )
      {
         fclose $fileid;
         error -showLineNumber true "No key attributes found. Check animation baking, layer setting";
      }


      //Print number of channels
      if ( !( $isFacial ) )
      {
         $nchannels = $njoints + 3; // all joints' rotations + root 3 translations
      }
      else
      {
         $nchannels = $njoints * 4; // all joints have 1 rotation and 3 translations
      }

      fprint $fileid ( "channels " + $nchannels + "\n" );

      skmWriteSkm( $startFrame, $endFrame, $joints, $fileid, $fps );
      fprint $fileid ( "\n\n" );


      //grab synch point values
      int $readyVal =       `getAttr( $AnimDef + ".readyTime" )`;
      int $strokeStartVal = `getAttr( $AnimDef + ".strokeStartTime" )`;
      int $emphasisVal =    `getAttr( $AnimDef + ".emphasisTime" )`;
      int $strokeVal =      `getAttr( $AnimDef + ".strokeTime" )`;
      int $relaxVal =       `getAttr( $AnimDef + ".relaxTime" )`;

      //convert synch point values from frames to seconds
      float $readySeconds =       float( $readyVal ) / $fps;
      float $strokeStartSeconds = float( $strokeStartVal ) / $fps;
      float $emphasisSeconds =    float( $emphasisVal ) / $fps;
      float $strokeSeconds =      float( $strokeVal ) / $fps;
      float $relaxSeconds =       float( $relaxVal ) / $fps;

      //print synch point values
      fprint $fileid ( "ready time: "+ $readySeconds + "\n" );
      fprint $fileid ( "strokeStart time: "+ $strokeStartSeconds + "\n" );
      fprint $fileid ( "emphasis time: "+ $emphasisSeconds+ "\n" );
      fprint $fileid ( "stroke time: " + $strokeSeconds + "\n" );
      fprint $fileid ( "relax time: "+ $relaxSeconds + "\n" );
   }

   fclose( $fileid );

   print( "Export done.\n" );

   return 1;
}







////////////////////////////////////////////////////////////////
//  GUI CODE
////////////////////////////////////////////////////////////////


global proc int skmFileCb( string $filename, string $fileType )
{
   string $name = basename( $filename, "");
   string $dirname = dirname( $filename );
   print ($dirname + "\n");
   textFieldGrp -e -text $name skmOutputFile;
   textFieldGrp -e -text $dirname skmOutputPath;
   updateOutput;
   return 1;
}


// This will update files created with older versions of the SKM exporter
proc skmUpdateOldFiles( string $newAnimName )
{
   // Updates to v0.7

   int $tempInt;

   if ( `objExists fpsNode` )
   {
      if ( `attributeExists framesPerSecond fpsNode` )
      {
         int $tempInt = `getAttr "fpsNode.framesPerSecond"`;
         setAttr ( "AnimDef_" + $newAnimName + ".framesPerSecond" ) $tempInt;
      }

      delete fpsNode;
      print "Old fpsNode deleted! \n";
   }

   if ( `objExists firstFrameNode` )
   {
      if ( `attributeExists framesPerSecond firstFrameNode` )
      {
         int $tempInt = `getAttr "firstFrameNode.firstFrameNumber"`;
         setAttr ( "AnimDef_" + $newAnimName + ".firstFrameNumber") $tempInt;
      }

      delete firstFrameNode;
      print "Old firstFrameNode deleted! \n";
   }

   if ( `objExists lastFrameNode` )
   {
      if ( `attributeExists lastFrameNumber lastFrameNode` )
      {
         int $tempInt = `getAttr "lastFrameNode.lastFrameNumber"`;
         setAttr ( "AnimDef_" + $newAnimName + ".lastFrameNumber" ) $tempInt;
      }

      delete lastFrameNode;
      print "Old lastFrameNode deleted! \n";
   }

   if ( `objExists readyNode` )
   {
      if ( `attributeExists readyTime readyNode` )
      {
         int $tempInt = `getAttr "readyNode.readyTime"`;
         setAttr ( "AnimDef_" + $newAnimName + ".readyTime" ) $tempInt;
      }

      delete readyNode;
      print "Old readyNode deleted! \n";
   }

   if ( `objExists strokeStartNode` )
   {
      if ( `attributeExists strokeStartTime strokeStartNode` )
      {
         int $tempInt = `getAttr "strokeStartNode.strokeStartTime"`;
         setAttr ( "AnimDef_" + $newAnimName + ".strokeStartTime" ) $tempInt;
      }

      delete strokeStartNode;
      print "Old strokeStartNode deleted! \n";
   }

   if ( `objExists emphasisNode` )
   {
      if ( `attributeExists emphasisTime emphasisNode` )
      {
         int $tempInt = `getAttr "emphasisNode.emphasisTime"`;
         setAttr ( "AnimDef_" + $newAnimName + ".emphasisTime" ) $tempInt;
      }

      delete emphasisNode;
      print "Old emphasisNode deleted! \n";
   }

   if ( `objExists strokeNode` )
   {
      if ( `attributeExists strokeTime strokeNode` )
      {
         int $tempInt = `getAttr "strokeNode.strokeTime"`;
         setAttr ( "AnimDef_" + $newAnimName + ".strokeTime" ) $tempInt;
      }

      delete strokeNode;
      print "Old strokeNode deleted! \n";
   }

   if ( `objExists relaxNode` )
   {
      if ( `attributeExists relaxTime relaxNode` )
      {
         int $tempInt = `getAttr "relaxNode.relaxTime"`;
         setAttr ( "AnimDef_" + $newAnimName + ".relaxTime" ) $tempInt;
      }

      delete relaxNode;
      print "Old relaxNode deleted! \n";
   }
}


global proc skmAddAnimDef()
{
   string $result = `promptDialog -title "Define New Animation" -message "Animation Name?"
               -button "OK" -button "Cancel"
               -defaultButton "OK" -cancelButton "Cancel"
               -dismissString "Cancel"`;

   if ( $result == "OK" )
   {
      $newAnimName = `promptDialog -query -text`;
      textScrollList -edit -append $newAnimName scrollListAnim;

      // Create node with setting attributes
      group -n ( "AnimDef_" + $newAnimName ) -em -p SmartbodyExportOptions;
      addAttr -ln "framesPerSecond" -sn "frmsps" -at "long" -min 1 -dv 30 ( "AnimDef_" + $newAnimName );
      addAttr -ln "firstFrameNumber" -sn "fFrm" -at "long" ( "AnimDef_" + $newAnimName );
      addAttr -ln "lastFrameNumber" -sn "lFrm" -at "long" ( "AnimDef_" + $newAnimName );
      addAttr -ln "readyTime" -sn "rdyTime" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "strokeStartTime" -sn "sStart" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "emphasisTime" -sn "seTime" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "strokeTime" -sn "sEnd" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "relaxTime" -sn "rlxTime" -at "double" ( "AnimDef_" + $newAnimName );

      addAttr -ln "skeletonRoot" -sn "skRoot" -dt "string" ( "AnimDef_" + $newAnimName );
      setAttr -type "string" ( "AnimDef_" + $newAnimName + ".skeletonRoot" ) "base";

      addAttr -ln "outputFile" -sn "outFile" -dt "string" ( "AnimDef_" + $newAnimName );
      setAttr -type "string" ( "AnimDef_" + $newAnimName + ".outputFile" ) ( $newAnimName + ".skm" );

      textScrollList -edit -si $newAnimName scrollListAnim;
      updateAnimUI;

      print( "New animation definition created: " + $newAnimName + "\n" );
   }
}


global proc skmDeleteAnimDef()
{
   $selAnim = `textScrollList -q -si scrollListAnim`;
   textScrollList -edit -ri $selAnim scrollListAnim;
   delete ( "AnimDef_" + $selAnim[ 0 ] );

   print( "Animation definition deleted: " + $selAnim[ 0 ] + "\n" );
}


global proc skmRenameAnimDef()
{
   string $selAnim[];
   string $selAnimDef;
   string $newAnimName;

   // Get curernt animation name
   $selAnim = `textScrollList -q -si scrollListAnim` ;

   // Create "new name" prompt window
   string $PromptResult = `promptDialog -title "Rename Selected Animation" -message "New Animation Name?"
               -button "Rename" -button "Cancel"
               -defaultButton "Rename" -cancelButton "Cancel"
               -dismissString "Cancel"`;

   // Update naming
   if ( $PromptResult == "Rename" )
   {
      $newAnimName = `promptDialog -query -text`;
      textScrollList -edit -ri $selAnim[ 0 ] scrollListAnim;
      textScrollList -edit -append $newAnimName scrollListAnim;
      rename( "AnimDef_" + $selAnim[ 0 ] ) ( "AnimDef_" + $newAnimName );
      textScrollList -edit -si $newAnimName scrollListAnim;
      updateAnimUI;
   }

   print( "Animation definition renamed from: " + $selAnim[ 0 ] + " to " + $newAnimName + "\n" );
}


global proc updateAnimUI()
{
   // Get animation definition name
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );

   // First and last frame
   int $firstFrame = `getAttr( $AnimDef + ".firstFrameNumber" )`;
   intSliderGrp -edit -value $firstFrame skmFirstFrameSlider;

   int $lastFrame = `getAttr( $AnimDef + ".lastFrameNumber" )`;
   intSliderGrp -edit -value $lastFrame skmLastFrameSlider;

   // Synch points
   int $readyFrame = `getAttr( $AnimDef + ".readyTime" )`;
   intSliderGrp -edit -min $firstFrame -max $lastFrame -value $readyFrame sliderReady;

   int $strokeStartFrame = `getAttr( $AnimDef + ".strokeStartTime" )`;
   intSliderGrp -edit -min $firstFrame -max $lastFrame -value $strokeStartFrame sliderStrokeStart;

   int $emphasisFrame = `getAttr( $AnimDef + ".emphasisTime" )`;
   intSliderGrp -edit -min $firstFrame -max $lastFrame -value $emphasisFrame sliderEmphasis;

   int $strokeEndFrame = `getAttr( $AnimDef + ".strokeTime" )`;
   intSliderGrp -edit -min $firstFrame -max $lastFrame -value $strokeEndFrame sliderStrokeEnd;

   int $relaxFrame = `getAttr( $AnimDef + ".relaxTime" )`;
   intSliderGrp -edit -min $firstFrame -max $lastFrame -value $relaxFrame sliderRelax;

   // Misc other info
   int $fps = `getAttr( $AnimDef  + ".framesPerSecond" )`;
   intSliderGrp -edit -value $fps sliderFps;

   string $skeletonRoot = `getAttr( $AnimDef + ".skeletonRoot" )`;
   textFieldGrp -edit -text $skeletonRoot skmRootField;

   string $outputFile = `getAttr( $AnimDef + ".outputFile" )`;
   skmFileCb( $outputFile, "" );
   
   string $pjname = `textFieldGrp -q -text skmPartialExportJointField`;
   if( $pjname == "" )
      textFieldGrp -e -text $skeletonRoot skmPartialExportJointField;

}


global proc toggleIsFacial()
{
   global int $isFacial;

   if ( $isFacial )
   {
      $isFacial = 0;
   }
   else
   {
      $isFacial = 1;
   }
}

global proc togglePartialExport()
{
   global int $partialExportToggle;
   if( $partialExportToggle )
   {
      $partialExportToggle = 0;
   }
   else
   {
      $partialExportToggle = 1;
   }
}


global proc infoPressed()
{
   confirmDialog -title "Ready Stroke Relax help" -message "Ready: Anticipation for the stroke (or action)  \nStroke: Climax of Action- point of greatest emphasis \nRelax: Follow-Thru and Settle of the action \nfor more information consult http://twiki.isi.edu/Public/BMLSpecification" -button "close"  -defaultButton "close";
}


global proc fpsUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   $fps = `intSliderGrp -q -value sliderFps`;
   setAttr( $AnimDef + ".framesPerSecond" ) $fps;
}


global proc firstFrameUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );

   int $frameNumber = `intSliderGrp -query -value skmFirstFrameSlider`; // the animator is at this framenumber
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
   //setAttr "SmartbodyExportOptions.firstFrameNumber" $frameNumber;
   setAttr ( $AnimDef + ".firstFrameNumber" ) $frameNumber;

   //updates ready stroke relax sliders
   intSliderGrp -edit -min $frameNumber sliderReady;
   intSliderGrp -edit -min $frameNumber sliderStrokeStart;
   intSliderGrp -edit -min $frameNumber sliderEmphasis;
   intSliderGrp -edit -min $frameNumber sliderStrokeEnd;
   intSliderGrp -edit -min $frameNumber sliderRelax;
}


global proc lastFrameUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" ` ;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );

   int $frameNumber = `intSliderGrp -query -value skmLastFrameSlider`; // the animator is at this framenumber
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
   setAttr ( $AnimDef + ".lastFrameNumber" ) $frameNumber;
   //setAttr "SmartbodyExportOptions.lastFrameNumber" $frameNumber;

   //updates ready stroke relax sliders
   intSliderGrp -edit -max $frameNumber sliderReady;
   intSliderGrp -edit -max $frameNumber sliderStrokeStart;
   intSliderGrp -edit -max $frameNumber sliderEmphasis;
   intSliderGrp -edit -max $frameNumber sliderStrokeEnd;
   intSliderGrp -edit -max $frameNumber sliderRelax;
}


global proc readyUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   int $frameNumber = `intSliderGrp -query -value sliderReady`; // the animator is at this framenumber
   setAttr ( $AnimDef + ".readyTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc strokeStartUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   int $frameNumber = `intSliderGrp -query -value sliderStrokeStart`; // the animator is at this framenumber
   setAttr ( $AnimDef + ".strokeStartTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc emphasisUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   int $frameNumber = `intSliderGrp -query -value sliderEmphasis`; // the animator is at this framenumber
   setAttr ( $AnimDef + ".emphasisTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc strokeUpdate ()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   int $frameNumber = `intSliderGrp -query -value sliderStrokeEnd`; // the animator is at this framenumber
   setAttr ( $AnimDef + ".strokeTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc relaxUpdate()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   int $frameNumber = `intSliderGrp -query -value sliderRelax`; // the animator is at this framenumber
   setAttr ( $AnimDef + ".relaxTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc updateSkeletonRoot()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   $skeletonRoot = `textFieldGrp -q -text skmRootField` ;
   setAttr -type "string" ( $AnimDef + ".skeletonRoot" ) $skeletonRoot ;
   updatePartialExportJoint;   
}


// For partial animation exporting
// Update the joint that you want to export from
global proc updatePartialExportJoint()
{
   string $pjname = `textFieldGrp -q -text skmPartialExportJointField`;
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );     
   string $skeletonRoot = `getAttr( $AnimDef + ".skeletonRoot" )`;
   
   select -cl;
   int $flag = `joint -exists $pjname`;
   if( $flag == 0 )
   {
      warning -showLineNumber true "partial not exist, please re-enter";
      textFieldGrp -e -text $skeletonRoot skmPartialExportJointField;   
   }
   $flag = 0;
   string $children[] = `ls -dag $skeletonRoot`; 
   int $i;
   for( $i = 0 ; $i < size($children); $i = $i + 1)
      if( $children[ $i ] == $pjname ) {$flag = 1; break;} 
   if($flag == 0) 
   {
      warning -showLineNumber true "partial joint is not under root hierarchy!";
      textFieldGrp -e -text $skeletonRoot skmPartialExportJointField;   
   }
}

// outputFile Attribute now is composed of directory name and file name
global proc updateOutput()
{
   string $selAnim[] = `textScrollList -q -si "scrollListAnim" `;
   string $AnimDef = ( "AnimDef_" + $selAnim[ 0 ] );
   string $outputFileName = `textFieldGrp -q -text skmOutputFile`;
   string $outputFilePath = `textFieldGrp -q -text skmOutputPath`;
   if( $outputFilePath == "")	
   {
      $outputFilePath = `pwd`;
      textFieldGrp -edit -text $outputFilePath skmOutputPath;
   }
   int $flag = `filetest -d $outputFilePath`;
   if( $flag == 0 )
      warning -showLineNumber true "Please check the input directory!";
   string $testfilename = basename($outputFileName, ".skm");
   if( $testfilename == $outputFileName)
      warning -showLineNumber true "Please check the suffix of output file, should be .skm!";
   $outputFile = $outputFilePath + "/" + $outputFileName;
   setAttr -type "string" ( $AnimDef + ".outputFile" ) $outputFile ;
   print "~~~~~~~~~~~~~~~~~";
}


global proc skmExportButton()
{
   global string $skmVersion;
   global int $partialExportToggle;

   string $tempList[];
   string $AnimDefList[];
   int $ArraySize;
   int $ArrayPos;


   print "Beginning export... \n" ;

   // Grab synch point values and check to see if they are valid
   select -hi SmartbodyExportOptions;
   $tempList = `ls -sl`;

   // Add animation definitions to $AnimDefList
   for ( $obj in $tempList )
   {
      if ( `substring $obj 1 7` == "AnimDef" )
      {
         $ArraySize = `size( $AnimDefList )`;
         $ArrayPos = $ArraySize;
         $AnimDefList[ $ArrayPos ] = $obj;

         print( "Put " + $obj + " in " + $ArrayPos + "\n" );
      }
   }

   for ( $AnimDef in $AnimDefList )
   {
      // Get synch point values and make sure they are correct
      int $readyVal =       `getAttr( $AnimDef + ".readyTime" )`;
      int $strokeStartVal = `getAttr( $AnimDef + ".strokeStartTime" )`;
      int $emphasisVal =    `getAttr( $AnimDef + ".emphasisTime" )`;
      int $strokeVal =      `getAttr( $AnimDef + ".strokeTime" )`;
      int $relaxVal =       `getAttr( $AnimDef + ".relaxTime" )`;

      if ( $readyVal <= $strokeStartVal && $strokeStartVal <= $emphasisVal && $emphasisVal <= $strokeVal && $strokeVal <= $relaxVal )
      {
         // Check to see if ik handles exist
         string $iklist[] = `ls -l -type ikHandle`;
         string $but = "Continue";

         if ( size( $iklist ) > 0 )
         {
            $but = `confirmDialog -title "Confirm"
                                  -message "IK handles exist; animation must be baked"
                                  -button "Continue" -button "Abort" -defaultButton "Continue"
                                  -cancelButton "No" -dismissString "No"`;
         }

         if ( strcmp( $but,"Continue" ) == 0 )
         {
            int $startFrame = `getAttr( $AnimDef + ".firstFrameNumber" )`;
            int $endFrame =   `getAttr( $AnimDef + ".lastFrameNumber" )`;
            string $root =    `getAttr( $AnimDef + ".skeletonRoot" )`;
            string $file =    `getAttr( $AnimDef + ".outputFile" )`;
            int $fps =        `getAttr( $AnimDef + ".framesPerSecond" )`;

            if( $partialExportToggle == 0 )
            {
               string $pjname = `textFieldGrp -q -text skmPartialExportJointField`;
               select -r $pjname;            
            }
            else
               select -r $root ;   // <-Why select this?
            skmExport( $file, $AnimDef, $startFrame, $endFrame, $fps, $skmVersion );
         }
      }
      else
      {
         confirmDialog -title "ERROR: Invalid Synch Point Times" -message "Invalid times given for Ready, Stroke, Relax: make sure Relax occurs after Ready and Stroke etc. Hit help button for more information" -button "close"  -defaultButton "close";
      }
   }
}


// This creates the main UI window
global proc skmExportGUI()
{
   global string $skmVersion;
   global int $isFacial;

   if ( ( `window -exists skmMainWin` ) == true )
   {
      deleteUI skmMainWin;
      windowPref -remove skmMainWin;
   }

   //BUILD UI WINDOW
   string $winTitle = "SKM Exporter v" + $skmVersion ;
   window -title $winTitle -rtf true -s true skmMainWin;
   columnLayout -adj true -cat "both" 5;
      frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -label "Animation Definitions";
         columnLayout -adj true -rs 2 -co "both" 10;
            textScrollList  -numberOfRows 3 -w 250 -allowMultiSelection false
                            -showIndexedItem 4 -selectCommand updateAnimUI scrollListAnim;
            rowColumnLayout -numberOfRows 1 -rh 1 20 -rs 1 2 -cat 1 "right" 3;
               button -label "Create Animation"  -align "center" -command "skmAddAnimDef";
               button -label "Rename Animation"  -align "center" -command "skmRenameAnimDef";
               button -label "Delete Animation"  -align "center" -command "skmDeleteAnimDef";
               setParent skmMainWin;
   checkBox -editable false -label "Loaded from existing \"SmatbodyExportOptions\" node" -align "left" loadedBox;
   checkBox -editable false -changeCommand "toggleIsFacial()" -value false -label "Facial Animations" -align "left" facialBox;
   checkBox -editable false -changeCommand "togglePartialExport()" -value false -label "Partial Animation Exporting- ON: Zero-out OFF: Eliminate Other joints " -align "left" partialExportBox;
   
   frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -label "Animation Length & Synch Points";
      columnLayout -adj true;
         intSliderGrp -label "First Frame:" -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand firstFrameUpdate skmFirstFrameSlider; 
         intSliderGrp -label "Last Frame:"  -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand lastFrameUpdate skmLastFrameSlider;
         columnLayout -adj true -rs 2 -co "both" 10;
            button -label "Stroke, Ready, Relax Help" -align "center" -command infoPressed;
            setParent .. ;
         intSliderGrp -label "Ready End Frame"     -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand readyUpdate sliderReady ;
         intSliderGrp -label "Stroke Start Frame:" -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand strokeStartUpdate sliderStrokeStart ;
         intSliderGrp -label "Emphasis Frame:"     -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand emphasisUpdate sliderEmphasis ;
         intSliderGrp -label "Stroke End Frame:"   -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand strokeUpdate sliderStrokeEnd ; 
         intSliderGrp -label "Relax End Frame:"    -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand relaxUpdate sliderRelax ; 
         setParent skmMainWin;
   frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -label "Export Setup";
      columnLayout -adj true;
         intSliderGrp -label "Frames per Seconds:" -adj 3 -cw 2 50 -cat 1 "right" 5 -field true -fmn -10000 -fmx 10000 -changeCommand fpsUpdate -min 1 -value 30 sliderFps; //<- was "skmFps"
         textFieldGrp -label "Skeleton Root Joint:" -adj 2 -cat 1 "right" 5 -changeCommand updateSkeletonRoot skmRootField;
         textFieldGrp -label "Partial Exporting, From Joint:" -adj 2 -cat 1 "right" 5 -changeCommand updatePartialExportJoint skmPartialExportJointField;
         textFieldGrp -label "Output Pathname:" -adj 2 -cat 1 "right" 5 -changeCommand updateOutput skmOutputPath;
         textFieldGrp -label "Output Filename:" -adj 2 -cat 1 "right" 5 -changeCommand updateOutput skmOutputFile;
         columnLayout -adj true -rs 2 -co "both" 10;
            button -l "Browse Output File" -command "fileBrowserDialog -m 1 -fc \"skmFileCb\" -an \"Select\" -om \"SaveAs\"";
            setParent skmMainWin;
   frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -lv false;
      columnLayout -adj true -rs 5 -co "both" 10;
         button -l "Export Animation" -command "skmExportButton()";
         setParent skmMainWin;

   //ADD INFO NODES & ATTRIBUTES
   //Create SmartbodyExportOptions node if it doesn't yet exist
   if ( !`objExists "SmartbodyExportOptions"` )
   {
      checkBox -edit -value false loadedBox;
      group -empty -name "SmartbodyExportOptions";
      setAttr "SmartbodyExportOptions.visibility" 0;
   }
   else
   {
      checkBox -edit -value true loadedBox;
   }

   //Check to see if there are any existing animation definitions
   select -hi SmartbodyExportOptions;
   string $tempList[] = `ls -sl`;
   float $animDefsExist = 0;

   for ( $obj in $tempList )
   {
      if ( `substring $obj 1 7` == "AnimDef" )
      {
         $animDefsExist = 1;
         print "Found existing animation definitions. \n";
      }
   }

   string $newAnimName;

   //If no animation definitions exist create a default animation definition
   if ( $animDefsExist == 0 )
   {
      //Create node with setting attributes
      $newAnimName = "DefaultAnim";

         //this bit is meant to get the scene name and anme the anim the same name, not currently working
         /*
         string $FileName = `file -q -sceneName`;
         string $splitFileName[] ;
         int $TempToken = `tokenize $FileName "." $splitFileName` ;
         
         if ($splitFileName[0] == "") {
            $newAnimName = "UnnamedAnim" ;
         }
         else {
            $newAnimName = $splitFileName[0] ; 	
         }
         */

      textScrollList -edit -append $newAnimName scrollListAnim;
      group -n ( "AnimDef_" + $newAnimName ) -em -p SmartbodyExportOptions;

      addAttr -ln "framesPerSecond" -sn "frmsps" -at "long" -min 1 -dv 30 ( "AnimDef_" + $newAnimName );
      addAttr -ln "firstFrameNumber" -sn "fFrm" -at "long" ( "AnimDef_" + $newAnimName );
      addAttr -ln "lastFrameNumber" -sn "lFrm" -at "long" ( "AnimDef_" + $newAnimName );
      addAttr -ln "readyTime" -sn "rdyTime" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "strokeStartTime" -sn "sStart" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "emphasisTime" -sn "seTime" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "strokeTime" -sn "sEnd" -at "double" ( "AnimDef_" + $newAnimName );
      addAttr -ln "relaxTime" -sn "rlxTime" -at "double" ( "AnimDef_" + $newAnimName );

      addAttr -ln "skeletonRoot" -sn "skRoot" -dt "string" ( "AnimDef_" + $newAnimName );
      setAttr -type "string" ( "AnimDef_" + $newAnimName + ".skeletonRoot" ) "base";

      addAttr -ln "outputFile" -sn "outFile" -dt "string" ( "AnimDef_" + $newAnimName );
      setAttr -type "string" ( "AnimDef_" + $newAnimName + ".outputFile" ) ( $newAnimName + ".skm" );

      textScrollList -edit -si $newAnimName scrollListAnim;
      updateAnimUI;

      print( "Default animation definition created: " + $newAnimName + "\n" );
   }

   //Check for pre 0.7 info nodes and transfer their info to default node
   skmUpdateOldFiles( $newAnimName );

   //If animation definitions do exist add these to the UI
   if ( $animDefsExist == 1 )
   {
      for ( $obj in $tempList )
      {
         if ( `substring $obj 1 7` == "AnimDef" )
         {
            string $AnimName = `substring $obj 9 250`;
            textScrollList -edit -append $AnimName scrollListAnim;
            //print "Found existing animation definitions. \n";
         }
      }
   }


   showWindow skmMainWin;

   print "SKM Exporter window created. \n" ;
}



/*----------------------------------------
SCRIPT INFO
  - joints can have no key data or rotation data, only root may contain translation
  - The order of the joint rotations is considered to be Euler XYZ
  - You cannot change the default name of the animation curves (they have to have the form jointName_rotateX, etc)
  - If the animation uses IK handles, it must be baked before the export
  - To make sure the animation export will be fine, remove all IK handles and check if the animation in Maya is still correct
  - Although the script checks it, it is a good idea to change the settings to cms
 
KNOWN ISSUES
 - under certain conditions, which I have not been able to determine, the output file path will disappear
  
VERSION HISTORY:
  0.1 - first version
  0.2 - smaller files exported (less decimals used)
  0.3 - rounding 5th decimal
  0.4 - corrected recursing into joint hierarchy even if joint has no keys
  Modifications by Ashok Basawapatna
  0.5 - interim solution to allow artists to specify ready, stroke, and relax using the frame numbers (a more graphical solution should be constructed), frame numbers are converted into time values and written to the bottom of the skm in the followin format
	ready time: 0.9333333333
	stroke time: 1.433333333
	relax time: 1.933333333 
  0.6 - another interim solution-- gives the artist access to the time slider for all sliders in order to specify ready, stroke, and relax;start and end frame again writes the times to the bottom of the skm
	adds help button to explain ready, stroke, relax to the artist and also has error check to make sure ready, stroke, relax are valid times
  0.7 - changes by Matt Liewer (liewer@ict.usc.edu)
	disabled timeline resizing when first and last frame values changed
	put all export option attributes onto one node "SmartbodyExportOptions"
	commented code a bit
	general streamlinining of script
	re-organized interface
  0.8 - changes by Matt Liewer (liewer@ict.usc.edu)
	when UI is opened it will check for info created by older version of the exporter and upadte this info to new system
	can now define and export multiple animations per file
*/
