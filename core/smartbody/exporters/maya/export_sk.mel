//  export_sk.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Andrew n marshall, USC
//      Kristin Parker, USC



// --------------------------------------------------------------------------------
// PROC: skRound
// This will round a number to a certain precision, the bulk of this script actuall deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if (`substring $valueString 1 1` == "-") {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ($value * $multiplyer) ;
   $value = ($value + 0.5) ;
   $value = `trunc $value` ;
   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;
   //print ($value + "\n") ;
   //print ("StringSize: " + $StringSize + "\n") ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ($StringSize <= 5) {

      $SmallValues = 1 ;

      int $dif = (5 - $StringSize) ;
      if ($dif == 4) {
         $zeroes = "0000" ;
      }
      else if ($dif == 3) {
         $zeroes = "000" ;
      }
      else if ($dif == 2) {
         $zeroes = "00" ;
      }
      else if ($dif == 1) {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ($zeroes + $valueString) ;
      //print ($valueString + "\n") ;
   }

   //Assemble new strings
   if ($SmallValues == 1) {
      $wholeNumber = "0" ;
   }
   else {
      $wholeNumber = `substring $valueString 1 ($StringSize-$precision)` ;
   }

   $decNumber = `substring $valueString ($StringSize-($precision-1)) ($StringSize)` ;  //this seems unneccesarry

   $valueString = ($sign + $wholeNumber + "." + $decNumber) ;

   //Finish
   return $valueString ;


/*
   Old function
   float $precision = 5;
   $power = pow( 10, $precision );
   $value = $value * $power;
   $value = int ( $value + ( $value < 0 ? -0.5 : 0.5 ) );
   $value = $value / $power;
   return $value;
*/
}


proc int skMargin( int $fileid, int $depth )
{
   for ( $k = 0; $k < $depth; $k++ )
      fprint $fileid ("  ");

   return 1;
}


proc int skWriteSk( string $jname, int $fileid, int $depth, int $showAll, int $useLimits )
{
   //=== Get Children ===
   string $children[];
   $children = `listRelatives $jname`;
   int $nchildren = `size $children`;


   string $type = nodeType( $jname );


   // Write info for meshes
   if ( $type == "mesh" )
   {
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "visgeo \"" + $jname + ".obj\"\r\n" );
      skMargin( $fileid, $depth - 1 );
      fprint $fileid ( "colgeo \"" + $jname + ".obj\"\r\n" );
   }


   // If object is not of type "joint" then recurse
   // HACK - initial_base is of type "transform", but we want to include it and not skip it.
   if ( $type != "joint" && $jname != "initial_base" )
   {
      if ( $type != "mesh" )
      {
         print( "Skipping " + $jname + ": " + $type + "\n" );
      }

      for ( $i = 0; $i < $nchildren; $i++ )
      {
         skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits );
      }

      return 1;
   }


   //=== Export Joint ===
   print( "Exporting joint " + $jname + "\n" );

   // Check if this is the root node of the hierarchy
   if ( $depth == 0 )
   {
      skMargin( $fileid, $depth );
      fprint $fileid ( "root " );
   }
   else
   {
      fprint $fileid ( "\r\n" );
      skMargin( $fileid, $depth );
      fprint $fileid ( "joint " );
   }

   fprint $fileid ( $jname + "\r\n" );

   skMargin ( $fileid, $depth );
   fprint $fileid ( "{ offset " );

   //Get and then write translation offsets
   float $offset[ 3 ];
   string $s = $jname + ".translateX";
   $offset[ 0 ] = `getAttr $s`;
   string $s = $jname + ".translateY";
   $offset[ 1 ] = `getAttr $s`;
   string $s = $jname + ".translateZ";
   $offset[ 2 ] = `getAttr $s`;

   fprint $fileid ( skRound( $offset[ 0 ] ) + " " + skRound( $offset[ 1 ] ) + " " + skRound( $offset[ 2 ] ) + "\r\n" );


   // Write translation channels and limits

   int $mntmn[] = ( `transformLimits -query -etx $jname` );
   float $xTransLimitValues[] = ( `transformLimits -query -tx $jname` );
   float $yTransLimitValues[] = ( `transformLimits -query -ty $jname` );
   float $zTransLimitValues[] = ( `transformLimits -query -tz $jname` );

   if ( $mntmn[ 0 ] && $mntmn[ 1 ] )
   {
      // limits exist
      if ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0" + " lim " + $xTransLimitValues[ 0 ] + " " + $xTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $xTransLimitValues[ 0 ] != $xTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
      }

      if ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0" + " lim " + $yTransLimitValues[ 0 ] + " " + $yTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $yTransLimitValues[ 0 ] != $yTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
      }

      if ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( $useLimits ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0" + " lim " + $zTransLimitValues[ 0 ] + " " + $zTransLimitValues[ 1 ] + "\r\n" );
      }
      else if ( ( $showAll ) || ( ( $zTransLimitValues[ 0 ] != $zTransLimitValues[ 1 ] ) && ( !$useLimits ) ) )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
   }
   else
   {
      if ( $showAll )
      {
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
      else if ( $jname == "base" )
      {
         // HACK - special case for the "base" joint.  Expose the position channels.  Need to find a way to do this through the exporter on a joint by joint basis

         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel XPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel YPos 0 free\r\n" );
         skMargin( $fileid, $depth + 1 );
         fprint $fileid ( "channel ZPos 0 free\r\n" );
      }
   }


   // Write rotation channel
   skMargin( $fileid, $depth + 1 );
   fprint $fileid ( "channel Quat\r\n" );


   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      skWriteSk( $children[ $i ], $fileid, $depth + 1, $showAll, $useLimits );
   }


   //=== End ===
   skMargin( $fileid, $depth );
   fprint $fileid ( "}\r\n" );

   return 1;
}


global proc int export_sk_NoGUI( string $fname, string $skname, string $version, int $showAll, int $useLimits )
{
   int $fileid = `fopen $fname "w"`;
   if ( $fileid == 0 )
   {
      error( "Could not open file: " + $fname );
      return 0;
   }

   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected!\n";
   }

   int $selectionListSize = `size $selectionList`;
   int $depth = 0;

   // EDF - This loop seems intended for multiple characters, or in the instance where multiple objects may be in the scene besides the character
   //       These cases haven't been tested, and probably will not produce correct results.  Watch out for this loop.
   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      print ( "----------SK Export Report----------\n" );

      fprint $fileid ( "# SK Skeleton Definition\r\n" );
      fprint $fileid ( "# File generated with export_sk_v" + $version + ".mel\r\n\r\n" );
      fprint $fileid ( "set_name " + $skname + "\r\n\r\n" );
      fprint $fileid ( "skeleton\r\n" );

      skWriteSk( $selectionList[ $j ], $fileid, $depth, $showAll, $useLimits );

      fprint $fileid ( "\r\n" );
      fprint $fileid ( "end\r\n" );
   }

   fclose( $fileid );
   print( "Export done.\n" );
   return 1;
}






////////////////////////////////////////////////////////////////
//  GUI CODE
////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////
//  Exports animation skeleton in .sk format for SmartBody
//  Requires SkViewer to bind the .objs to the .sk skeleton
//  Will create attribute nodes to keep exporter information between Maya sessions


global proc int skRootJointChanged()
{
   string $root = `textFieldGrp -q -text skRootField`;
   setAttr -type "string" SkelDef.RootJoint $root;
   return 1;
}


global proc int skNameChanged()
{
   string $name = `textFieldGrp -q -text skOutputName`;

   string $filepath = `textFieldGrp -q -text skOutputFile`;
   textFieldGrp -e -text ( `dirname($filepath)` + "/" + $name + ".sk" ) skOutputFile;

   setAttr -type "string" SkelDef.SkeletonName $name;


   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;

   return 1;
}


global proc int skOutputDirChanged()
{
   string $file = `textFieldGrp -q -text skOutputFile`;
   setAttr -type "string" SkelDef.OutputDirectory $file;
   return 1;
}


global proc int skFileCb( string $filename, string $fileType )
{
   textFieldGrp -e -text ($filename+"/"+`textFieldGrp -q -text skOutputName`+".sk") skOutputFile;
   return 1;
}


//--------------------------------------------------------------------------------
// PROC: skAddSkeletonDef
// This creates a "SkelDef" node to stire various attributes about the skeleton
//--------------------------------------------------------------------------------
proc skAddSkeletonDef()
{
   string $result = `promptDialog -title "Define New Skeleton" - message "Root Joint's Name?"
               - button "OK" -button "Cancel" -defaultButton "OK" 
               - cancelButton "Cancel" -dismissString "Cancel"`;

   if ( $result == "OK" )
   {
      $rootJointName = `promptDialog -query -text`;

      //make sure rootJointName is valid
      if ( `objExists $rootJointName` )
      {
         //valid joint entered
         group -n "SkelDef" -em -p SmartbodyExportOptions ;

         addAttr -ln "RootJoint" -dt "string" SkelDef ;
         setAttr -type "string" SkelDef.RootJoint $rootJointName;

         addAttr -ln "SkeletonName" -dt "string" SkelDef;
         setAttr -type "string" SkelDef.SkeletonName "default";

         addAttr -ln "OutputDirectory" -dt "string" SkelDef;
         setAttr -type "string" SkelDef.OutputDirectory "./default.sk";

         addAttr -ln "ShowAllChannels" -at bool SkelDef;
         setAttr SkelDef.ShowAllChannels false;

         addAttr -ln "UseLimits" -at bool SkelDef;
         setAttr SkelDef.UseLimits true;
      }
      else
      {
         //invalid joint entered
         string $errorMsg = $rootJointName + " is an invalid name for the root joint. Script has exited.\n ";
         error( $errorMsg );
      }
   }
}


global proc channelsChecked()
{
   //the show all channels box has been checked in the gui!
   setAttr SkelDef.ShowAllChannels true;
}


global proc channelsUnchecked()
{
   //the show all channels box has been unchecked in the gui!
   setAttr SkelDef.ShowAllChannels false;
}


global proc limitsChecked()
{
   //the use limits box has been checked in the gui!
   setAttr SkelDef.UseLimits true;
}


global proc limitsUnchecked()
{
   //the use limits box has been unchecked in the gui!
   setAttr SkelDef.UseLimits false;
}


//--------------------------------------------------------------------------------
// PROC: skExportWin
//--------------------------------------------------------------------------------
global proc skExportWin()
{

   source export_sk_NoGUI;


   global string $version = "0.3";

   //Creates SmartbodyExportOptions and SkelDef nodes if they don't exist
   if ( !`objExists SmartbodyExportOptions` )
   {
      //SmartbodyExportOptions needs to be created
      group -empty -name "SmartbodyExportOptions";
      setAttr "SmartbodyExportOptions.visibility" 0;
      skAddSkeletonDef();
   }
   else
   {
      if ( !`objExists SkelDef` )
      {
         //skeleton definition has not been made yet
         skAddSkeletonDef();
      }
   }

   //Build UI
   if ( ( `window -exists skMainWin` ) == true )
      deleteUI skMainWin;

   string $winTitle = "SK Exporter v" + $version + " - www.smartbody-anim.org";
   window -title $winTitle -wh 300 270 skMainWin;
   columnLayout -adjustableColumn true -columnAttach "both" 10 -rowSpacing 10 -columnWidth 290 MainColumn;
   textFieldGrp -label "Skeleton Root Joint:" -text `getAttr SkelDef.RootJoint` -cc "skRootJointChanged" skRootField;
   textFieldGrp -label "Output Character Name:" -text `getAttr SkelDef.SkeletonName` -cc "skNameChanged" skOutputName;
   textFieldGrp -label "Output File:" -text `getAttr SkelDef.OutputDirectory` -cc "skOutputDirChanged" skOutputFile;
   setParent MainColumn;
   columnLayout -columnAttach "both" 85 -columnWidth 290 - rowSpacing 5 CBRow2;
   setParent CBRow2;
   checkBox -label "Show All Channels" -value (`getAttr SkelDef.ShowAllChannels`) -onCommand "channelsChecked" -offCommand "channelsUnchecked" skShowAllChannels;
   checkBox -label "Use Limits" -value (`getAttr SkelDef.UseLimits`) -onCommand "limitsChecked" -offCommand "limitsUnchecked" skUseLimits;
   setParent MainColumn;
   button -l "Browse Output File" -command "fileBrowser(\"skFileCb\", \"Text\", \"\", 4)";
   button -l "Export" -command "skExport";
   showWindow skMainWin; 
}


//--------------------------------------------------------------------------------
// PROC: skExport
//--------------------------------------------------------------------------------
global proc skExport()
{
   global string $version;

   string $root   = `getAttr SkelDef.RootJoint`;
   string $name   = `getAttr SkelDef.SkeletonName`;
   string $file   = `getAttr SkelDef.OutputDirectory`;
   int $showAll   = `getAttr SkelDef.ShowAllChannels`;
   int $useLimits = `getAttr SkelDef.UseLimits`;

   select -r $root;
//   currentUnit -linear "cm";

   export_sk_NoGUI( $file, $name, $version, $showAll, $useLimits );
}


skExportWin;

//
// - Three steps are required in order to export a new skeleton/character from Maya:
//   1. Use this mel script to export a .sk skeleton definition file
//   2. Use the obj exporter mel script to export the used rigid models.
//      Make sure the objs are saved to the same directory of the sk file.
//   3. Finally, load the sk file in the metool.exe (the character will appear
//      with the models in strange places), and select the menu option 
//      Tools->convert skeleton. A new correct skeleton (with srm geometries) will be created.
// - All joints are exported with quaternion rotation channel
// - Only base joint is exported with translation channels
// - Maya should be set to cms
// - If "Mirror Joint" is used to create the skeleton in Maya, be sure to use the
//   "orientation" option (not "behavior")
//
