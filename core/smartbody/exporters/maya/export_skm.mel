//  export_skm.mel - part of SmartBody Project
//  Copyright (C) 2005-2008  University of Southern California
//
//  SmartBody is free software: you can redistribute it and/or
//  modify it under the terms of the Lesser GNU General Public License
//  as published by the Free Software Foundation, version 3 of the
//  license.
//
//  SmartBody is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  Lesser GNU General Public License for more details.
//
//  You should have received a copy of the Lesser GNU General Public
//  License along with SmartBody.  If not, see:
//      http://www.gnu.org/licenses/lgpl-3.0.txt
//
//  CONTRIBUTORS:
//      Marcelo Kallmann, USC (currently at UC Merced)
//      Ashok Basawapatna, USC (no longer)
//      Andrew n marshall, USC



////////////////////////////////////////////////////////////////
//  Exports animation in .skm format for SmartBody
//  Prompts for BML timing metadata


string $skmVersion = "1.2";
int $isFacial = 0;
int $partialExportToggle = 0;

//  g_names is a pseudo 2d array, containing something like:
//     l_hip_scaleX l_hip_scaleY l_hip_scaleZ l_hip_translateX l_hip_translateY l_hip_translateZ l_hip_rotateX l_hip_rotateY l_hip_rotateZ l_hip_visibility
//     l_knee_scaleX l_knee_scaleY l_knee_scaleZ l_knee_translateX l_knee_translateY l_knee_translateZ l_knee_rotateX l_knee_rotateY l_knee_rotateZ l_knee_visibility
//     etc...
global string $g_names[];
global int    $g_namesWidth;

global int $curJointsId;

//docServer(1);
updateRendererUI;


// --------------------------------------------------------------------------------
// PROC: skmRound
// This will round a number to a certain precision, the bulk of this script actually deals more with
// getting the number written out in a format Smartbody understands. In this case Smartbody doesn't
// use scientific notation for float values, which is something Maya often uses. So the solution is
// to convert these numeric values to strings.
// --------------------------------------------------------------------------------
proc string skmRound( float $value )
{
   //Declare variables
   string $valueString = $value;
   string $sign = "" ;
   string $wholeNumber ;
   string $decNumber ;

   //Store if $value is negative then get absolute value to simplify things
   if ( `substring $valueString 1 1` == "-" )
   {
      $sign = "-" ;
   }
   $value = `abs $value` ;

   //Round the value
   float $precision = 5 ;
   $multiplyer = pow( 10, $precision ) ;
   $value = ( $value * $multiplyer ) ;
   $value = ( $value + 0.5 ) ;
   $value = `trunc $value` ;

   //print ($value + "\n") ;

   //Covert $value to a string and get its size
   $valueString = $value ;
   $StringSize = `size $valueString` ;

   //print ( $value + "\n" ) ;
   //print ( "StringSize: " + $StringSize + "\n" ) ;

   //Deal with very small values
   string $zeroes = "" ;
   int $SmallValues = 0 ;
   if ( $StringSize <= 5 )
   {
      $SmallValues = 1 ;

      int $dif = ( 5 - $StringSize ) ;
      if ( $dif == 4 )
      {
         $zeroes = "0000" ;
      }
      else if ( $dif == 3 )
      {
         $zeroes = "000" ;
      }
      else if ( $dif == 2 )
      {
         $zeroes = "00" ;
      }
      else if ( $dif == 1 )
      {
         $zeroes = "0" ;
      }

      $StringSize = 5 ;
      $valueString = ( $zeroes + $valueString ) ;

      //print ( $valueString + "\n" ) ;
   }

   //Assemble new strings
   if ( $SmallValues == 1 )
   {
      $wholeNumber = "0" ;
   }
   else
   {
      $wholeNumber = `substring $valueString 1 ( $StringSize - $precision )` ;
   }

   $decNumber = `substring $valueString ( $StringSize - ( $precision - 1 ) ) ( $StringSize )` ;  //this seems unneccesarry

   $valueString = ( $sign + $wholeNumber + "." + $decNumber ) ;

   return $valueString ;
}


// procedures for emulating a 2d array, of a known width
proc string Get2dArrayString( string $s[], int $width, int $x, int $y )
{
   return $s[ ( $x * $width ) + $y ];
}


// procedures for emulating a 2d array, of a known width
proc Set2dArrayString( string $s[], int $width, int $x, int $y, string $value )
{
   $s[ ( $x * $width ) + $y ] = $value;
}


// make a quaternion from the given rotation around axis (x,y,z)
proc skmQuatSet( float $q[], float $x, float $y, float $z, float $degrees )
{
   float $radians = 3.1415926535897932 * $degrees / 180.0;

   // normalize axis:
   $q[ 1 ] = $x;
   $q[ 2 ] = $y;
   $q[ 3 ] = $z;

   float $f = $x * $x + $y * $y + $z * $z;

   if ( $f > 0 )
   {
      $f = sqrt( $f );
      $q[ 1 ] /= $f;
      $q[ 2 ] /= $f;
      $q[ 3 ] /= $f;
   }

   // set the quaternion:
   $radians /= 2;
   $f = sin( $radians );
   $q[ 1 ] *= $f;
   $q[ 2 ] *= $f;
   $q[ 3 ] *= $f;
   $q[ 0 ] = cos( $radians );
}


// quaternion multiplication
proc skmQuatMult( float $q[], float $q1[], float $q2[] )
{
   $q[ 0 ] = ( $q1[ 0 ] * $q2[ 0 ] ) - ( $q1[ 1 ] * $q2[ 1 ] + $q1[ 2 ] * $q2[ 2 ] + $q1[ 3 ] * $q2[ 3 ] ); // w1*w2-dot(v1,v2)
   $q[ 1 ] = $q1[ 2 ] * $q2[ 3 ] - $q1[ 3 ] * $q2[ 2 ]; // cross ($q1.v,$q2.v)
   $q[ 2 ] = $q1[ 3 ] * $q2[ 1 ] - $q1[ 1 ] * $q2[ 3 ];
   $q[ 3 ] = $q1[ 1 ] * $q2[ 2 ] - $q1[ 2 ] * $q2[ 1 ];
   $q[ 1 ] += ( $q1[ 1 ] * $q2[ 0 ] ) + ( $q2[ 1 ] * $q1[ 0 ] );
   $q[ 2 ] += ( $q1[ 2 ] * $q2[ 0 ] ) + ( $q2[ 2 ] * $q1[ 0 ] );
   $q[ 3 ] += ( $q1[ 3 ] * $q2[ 0 ] ) + ( $q2[ 3 ] * $q1[ 0 ] );
 }


// quaternion to axis-angle representation
proc quatToAxisAng( float $q[], float $aa[] )
{
   float $ang = 2.0 * acos( $q[ 0 ] );
   float $norm = sqrt( $q[ 1 ] * $q[ 1 ] + $q[ 2 ] * $q[ 2 ] + $q[ 3 ] * $q[ 3 ] );
   if ( $norm == 0 || $ang == 0 )
   {
      $aa[ 0 ] = 0;
      $aa[ 1 ] = 0;
      $aa[ 2 ] = 0;
   }
   else
   {
      $aa[ 0 ] = ( $q[ 1 ] / $norm ) * $ang;
      $aa[ 1 ] = ( $q[ 2 ] / $norm ) * $ang;
      $aa[ 2 ] = ( $q[ 3 ] / $norm ) * $ang;
    }
}


proc skmMergeAnimLayers()
{
   // this function is the same as selecting all anim layers, then going to Layers->Merge Layers
   // then unlocking the resulting layer


   string $layers[] = `ls -l -type animLayer`;
   if ( size( $layers ) <= 1 )
      return;


      //  Input Arguments:
      //      0 - Execute the command.
      //      1 - Show the option box dialog.
      //      2 - Return the command.

   print( "Merging Animation Layers, Maya file has been modified." + "\n" );
   layerEditorMergeAnimLayer( $layers, 0 );


   string $layers[] = `ls -l -type animLayer`;
   if ( size( $layers ) == 0 )
      return;    // something bad happened here with the merge, there should be one left over


   // unlock the layer
   animLayer -edit -lock 0 $layers[ 0 ];
}


// returns the index of the name containing $type, however
// $type is assumed to be at the end of each name
// (types are retrieved with: $names = `keyframe -q -name pinky3_l`;)
proc int skmSearchType( string $names[], string $type )
{
   int $size = size( $names );
   int $sizet = size( $type );

   for ( $i = 0; $i < $size; $i++ )
   {
      int $sizei = size( $names[ $i ] );
      string $subst = `substring $names[ $i ] ( $sizei - $sizet + 1 ) $sizei`;
      int $cmp = `strcmp $subst $type`;
      if ( $cmp == 0 )
         return $i;
   }

   return -1;
}


proc int skmCountJoints( string $jname, string $joints[] )
{
   global int $curJointsId;

   // Get children of $jname
   string $children[];
   $children = `listRelatives -children $jname`;
   int $nchildren = `size $children`;

   // Make sure $jname is a joint
   string $type = nodeType( $jname );
   if ( $type != "joint" )
   {
      return 0;
   }

   //=== Check if there are keys ===
   int $n = 1; // will remain 1 if joint is to be counted, 0 otherwise
   string $jnames[];
   $jnames = `keyframe -q -name $jname`;

   if ( size( $jnames ) == 0 )
      $n = 0; // no info

   if ( skmSearchType( $jnames, "ateX") == -1 &&
        skmSearchType( $jnames, "ateY") == -1 &&
        skmSearchType( $jnames, "ateZ") == -1 )
   {
      $n = 0; // no rotate or translate
   }

   //=== Count this joint if n is 1 ===
   if ( $n == 1 )
   {
      $joints[ $curJointsId ] = $jname;
      $curJointsId++;
   }

   //=== Recurse ===
   for ( $i = 0; $i < $nchildren; $i++ )
   {
      $n = $n + skmCountJoints( $children[ $i ], $joints );
   }
   
   return $n;
}


//to get key index:     keyframe -eval -index $key  -query $queryName
//to evaluate at frame: keyframe -eval -time $frame -query $queryName
proc float skmKeyVal( int $frame, string $queryName )
{
   global int $isFacial;

   float $val[];

   // if there is no key we search the 1st prior valid key for the joint
   while ( size( $val ) == 0 )
   {
      // Make sure frame won't be negative
      if ( ( $frame < 0 ) && ( $isFacial == 0 ) )
         $frame = 0;

      $val = `keyframe -eval -time $frame -query $queryName`;

      // Make sure frame 0 always have a valid key
      if ( ( $frame == 0 ) && ( size( $val ) == 0 ) )
         return 0;

      $frame = $frame - 1;
   }

   return $val[ 0 ];
}


proc skmCheckAndWriteKey( int $fileid, string $names[], string $type, int $frame, int $zeroChannelFlag )
{
   global int $isFacial;

   float $base;

   int $id = skmSearchType( $names, $type );

   //if ( $isFacial )
   //{
	  if ($id >= 0)
        $base = skmKeyVal( 0, $names[ $id ] );
   //}

   if ( $id >= 0 )
   {
      float $val = skmKeyVal( $frame, $names[ $id ] );

      //if ( $isFacial )
      //{
         $val = $val - $base;  // Subtract value at reference frame
      //}

      if ( $zeroChannelFlag != 0 )
         fprint $fileid ( " " + skmRound( $val ) );

      if ( $zeroChannelFlag == 0 )
         fprint $fileid ( " " + 0 );
   }
}


proc skmCheckAndWriteKeyQuat( int $fileid, string $names[], int $frame, int $zeroChannelflag )
{
   int $idx = skmSearchType( $names, "rotateX" );
   int $idy = skmSearchType( $names, "rotateY" );
   int $idz = skmSearchType( $names, "rotateZ" );
   if ( $idx < 0 && $idy < 0 && $idz < 0 )
      return;

   float $xa = 0;
   float $ya = 0;
   float $za = 0;
   if ( $idx >= 0 ) $xa = skmKeyVal( $frame, $names[ $idx ] );
   if ( $idy >= 0 ) $ya = skmKeyVal( $frame, $names[ $idy ] );
   if ( $idz >= 0 ) $za = skmKeyVal( $frame, $names[ $idz ] );

   float $qx[];
   float $qy[];
   float $qz[];
   skmQuatSet( $qx, 1, 0, 0, $xa );
   skmQuatSet( $qy, 0, 1, 0, $ya );
   skmQuatSet( $qz, 0, 0, 1, $za );

   // compose to zyx instead of xyz due to the used column-major matrix format
   float $qzyx[];
   float $qyx[];
   float $aa[];
   skmQuatMult( $qyx, $qy, $qx );
   skmQuatMult( $qzyx, $qz, $qyx );
   quatToAxisAng( $qzyx, $aa );

   if ( $zeroChannelflag != 0 )
      fprint $fileid ( " " + skmRound( $aa[ 0 ] ) + " " + skmRound( $aa[ 1 ] ) + " " + skmRound( $aa[ 2 ] ) );

   if ( $zeroChannelflag == 0 )
      fprint $fileid ( " " + 0 + " " + 0 + " " + 0 );
}


proc skmWriteKeyData( int $fileid, int $frame, string $jointName, int $jid, string $animDef, int $partialExportFlag )
{
   global string $g_names[];
   global int $g_namesWidth;
   global int $isFacial;

   string $names[];
   float $val[];
   int $i;
   int $trstart = 0;


   // Note: "keyframe -q -name  base;" returns:
   //       "base_translateZ base_translateX base_translateY base_rotateX base_rotateY base_rotateZ"

   // get used rotations/translations in the joint:
   //$names = `keyframe -q -name $jointName`;

   // the line above was too slow to be called per joint, per frame.
   // we stored the array in a 2d array at the beginning.  Now copy the
   // portion we're interested in to a single array
   for ( $i = 0; $i < $g_namesWidth; $i++ )
   {
      string $s = Get2dArrayString( $g_names, $g_namesWidth, $jid, $i );
      if ( $s == "" )
         break;

      $names[ $i ] = $s;
   }


   int $useChannelAttributes = `getAttr ( $animDef + ".UseChannelAttributes" )`;
   if ( $useChannelAttributes )
   {
      int $channelAttributePosX = 0;
      int $channelAttributePosY = 0;
      int $channelAttributePosZ = 0;
      int $channelAttributeQuat = 0;

      if ( `objExists ( $jointName + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $jointName + ".SbodyPosX" )`;
      if ( `objExists ( $jointName + ".SbodyPosY" )` )  $channelAttributePosY = `getAttr ( $jointName + ".SbodyPosY" )`;
      if ( `objExists ( $jointName + ".SbodyPosZ" )` )  $channelAttributePosZ = `getAttr ( $jointName + ".SbodyPosZ" )`;
      if ( `objExists ( $jointName + ".SbodyQuat" )` )  $channelAttributeQuat = `getAttr ( $jointName + ".SbodyQuat" )`;

      if ( $channelAttributePosX )  skmCheckAndWriteKey( $fileid, $names, "translateX", $frame, 1 );
      if ( $channelAttributePosY )  skmCheckAndWriteKey( $fileid, $names, "translateY", $frame, 1 );
      if ( $channelAttributePosZ )  skmCheckAndWriteKey( $fileid, $names, "translateZ", $frame, 1 );
      if ( $channelAttributeQuat )  skmCheckAndWriteKeyQuat( $fileid, $names, $frame, 1 );
   }
   else
   {
      // $partialExportFlag here indicates whether to zero out the channel, used for partial animation export

      if ( ( $jid == 0 ) || ( $isFacial ) ) // send translation only for root
      {
         skmCheckAndWriteKey( $fileid, $names, "translateX", $frame, $partialExportFlag );
         skmCheckAndWriteKey( $fileid, $names, "translateY", $frame, $partialExportFlag );
         skmCheckAndWriteKey( $fileid, $names, "translateZ", $frame, $partialExportFlag );
      }

      skmCheckAndWriteKeyQuat( $fileid, $names, $frame, $partialExportFlag );
   }
}


// This is where the joint name(s) and their translation channels are written
proc skmCheckAndWrite( int $fileid, string $names[], string $type, string $joint, string $skmtype )
{
	//Variables
	string $Tokens[] ;

	//Proc
	int $id = skmSearchType( $names, $type );
	if ( $id >= 0 ) {
		//print ("$joint: " + $joint + "\n") ;
		//print ("$skmtype: " + $joint + "\n") ;
		
		//remove any Maya namespace if it exists
		tokenize $joint ":" $Tokens ;
		$joint =  $Tokens[((size ($Tokens))-1)] ;
		
		
		fprint $fileid ( $joint + $skmtype );
	}
	else
	{
	   string $warningMsg = "Channel " + $joint + "_" + $type + " is missing\n";
	   confirmDialog -title "Warning On Channels" -message $warningMsg -button "close"  -defaultButton "close";
	}

	// Original //
	/*
   int $id = skmSearchType( $names, $type );
   if ( $id >= 0 )
      fprint $fileid ( $joint + $skmtype );
	 */
}


// This is where the joint name(s) and their quaternion channels are written
proc skmCheckAndWriteQuat( int $fileid, string $names[], string $joint )
{
	string $Tokens[] ;
   int $idx = skmSearchType( $names, "rotateX" );
   int $idy = skmSearchType( $names, "rotateY" );
   int $idz = skmSearchType( $names, "rotateZ" );
	if ( $idx >= 0 || $idy >= 0 || $idz >= 0 ) {
		
		//remove any Maya namespace if it exists
		tokenize $joint ":" $Tokens ;
		$joint =  $Tokens[((size ($Tokens))-1)] ;
		
		fprint $fileid ( $joint + " Quat\n" );
	}
	else
	{
	   string $warningMsg = "Rotation Channel of " + $joint + " is missing\n";
	   confirmDialog -title "Warning On Channels" -message $warningMsg -button "close"  -defaultButton "close";
	}	

	// Original //
	/*
   int $idx = skmSearchType( $names, "rotateX" );
   int $idy = skmSearchType( $names, "rotateY" );
   int $idz = skmSearchType( $names, "rotateZ" );
   if ( $idx >= 0 || $idy >= 0 || $idz >= 0 )
      fprint $fileid ( $joint + " Quat\n" );
	*/
}


proc skmWriteSkm( int $startFrame, int $endFrame, string $joints[], int $fileid, int $fps, string $animDef )
{
   global int $isFacial;

   global string $g_names[];
   global int $g_namesWidth;

   // Export translations and/or Quat rotations:
   global int $curJointsId;


   // find max width of names array so we can store in a hacked 2d array
   $g_namesWidth = 0;
   for ( $i = 0; $i < $curJointsId; $i++ )
   {
      string $names[] = `keyframe -q -name $joints[ $i ]`;
      if ( size( $names ) > $g_namesWidth )
      {
         $g_namesWidth = size( $names );
      }
   }

   for ( $i = 0; $i < $curJointsId; $i++ )
   {
      // Note: "keyframe -q -name  base;" returns:
      //       "base_translateZ base_translateX base_translateY base_rotateX base_rotateY base_rotateZ"

      string $names[] = `keyframe -q -name $joints[ $i ]`;

      // store our hacked 2d array for use later
      for ( $n = 0; $n < size( $names ); $n++ )
      {
         Set2dArrayString( $g_names, $g_namesWidth, $i, $n, $names[ $n ] );
      }


      int $useChannelAttributes = `getAttr ( $animDef + ".UseChannelAttributes" )`;
      if ( $useChannelAttributes )
      {
         int $channelAttributePosX = 0;
         int $channelAttributePosY = 0;
         int $channelAttributePosZ = 0;
         int $channelAttributeQuat = 0;
		 
		 //see if channel attributes exist & if so get their value
         if ( `objExists ( $joints[ $i ] + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $joints[ $i ] + ".SbodyPosX" )`;
         if ( `objExists ( $joints[ $i ] + ".SbodyPosY" )` )  $channelAttributePosY = `getAttr ( $joints[ $i ] + ".SbodyPosY" )`;
         if ( `objExists ( $joints[ $i ] + ".SbodyPosZ" )` )  $channelAttributePosZ = `getAttr ( $joints[ $i ] + ".SbodyPosZ" )`;
         if ( `objExists ( $joints[ $i ] + ".SbodyQuat" )` )  $channelAttributeQuat = `getAttr ( $joints[ $i ] + ".SbodyQuat" )`;

		 //if channel attributes are on/checked then write the channel
         if ( $channelAttributePosX )  skmCheckAndWrite( $fileid, $names, "translateX", $joints[ $i ], " XPos\n" );
		 if ( $channelAttributePosY )  skmCheckAndWrite( $fileid, $names, "translateY", $joints[ $i ], " YPos\n" );
         if ( $channelAttributePosZ )  skmCheckAndWrite( $fileid, $names, "translateZ", $joints[ $i ], " ZPos\n" );
         if ( $channelAttributeQuat )  skmCheckAndWriteQuat( $fileid, $names, $joints[ $i ] );
      }
      else
      {
         if ( ( $i == 0 ) || ($isFacial) ) // translation allowed only in root
         {
            skmCheckAndWrite( $fileid, $names, "translateX", $joints[ $i ], " XPos\n" );
            skmCheckAndWrite( $fileid, $names, "translateY", $joints[ $i ], " YPos\n" );
            skmCheckAndWrite( $fileid, $names, "translateZ", $joints[ $i ], " ZPos\n" );
         }

         skmCheckAndWriteQuat( $fileid, $names, $joints[ $i ] );
      }
   }

   // frames:
   float $kt = 0;
   float $ktstep = 1.0 / $fps;

   if ( $startFrame > $endFrame )
      $startFrame = $endFrame;

   fprint $fileid ( "\nframes " + ( $endFrame - $startFrame + 1 ) + "\n" );

//$startTime1 = `timerX`;

   string $peRootName = `getAttr ($animDef + ".partialExportRoot")` ;
   string $peRootChildren[] = `ls -dag $peRootName`;
   int $peRootChildrenNum = size( $peRootChildren );

   for ( $f = $startFrame; $f <= $endFrame; $f++ )
   {
      if ( $f % 10 == 0 || $f == $startFrame || $f == $endFrame )  print( "Writing frame " + $f +"/"+ $endFrame + "...\n" );

      fprint $fileid ( "kt " + $kt + " fr" );

      int $partialExportFlag = 0;
      int $partialExportCount = 0;
      for ( $i = 0; $i < $curJointsId; $i++ )
      {
         if ( $peRootName == $joints[ $i ] )
            $partialExportFlag = 1;

         if ( $partialExportFlag != 0 )
            $partialExportCount++;

         skmWriteKeyData( $fileid, $f, $joints[ $i ], $i , $animDef, $partialExportFlag );

         if ( $partialExportCount >= $peRootChildrenNum )
            $partialExportFlag = 0;
      }

      $kt += $ktstep;

      fprint $fileid ( "\n" );
   }

//$endTime1 = `timerX -st $startTime1`;
//print ( "TIME: skmWriteKeyData: " + $endTime1 + "\n" );
}


global proc int skmExportFile( string $fname, string $animDef )
{
   // Main entry point for exporting a single .skm
   // This function allows you to override the filename in the animDef.  If you don't need this, call skmExport().
   // If you wish to export all .skm's defined, call skmExportAll()
	print( "Running: proc: skmExportFile( $fname=" + $fname + ", $animDef=" + $animDef + "\n" );
   
   //Variables
   string $UnitsLinear = `currentUnit -q -linear` ;

   global string $skmVersion;
   global int $curJointsId = 0; // start filling at position 0 (root is at pos 0)
   global int $isFacial;


   // Check to see if ik handles exist
   string $iklist[] = `ls -l -type ikHandle`;
   if ( size( $iklist ) > 0 )
   {
      print( "\nWARNING - IK handles exist; animation must be baked\n\n" );
   }


   int $fileid = `fopen $fname "w"`;

   string $animName = basename( $fname, ".skm" );

   // Close file if nothing exists in scene    <-Is this really needed? -Matt
   $selectionList = `ls -sl`;
   if ( size( $selectionList ) <= 0 )
   {
      fclose $fileid;
      error "Nothing selected! \n";
   }

   int $selectionListSize = `size $selectionList`;
   for ( $j = 0; $j < $selectionListSize; $j++ )
   {
      $curJointsId = 0;

      //Print basic file information
      fprint $fileid ( "# SKM Motion Definition \n" );
      fprint $fileid ( "# Maya Exporter v" + $skmVersion + "    Units: " + $UnitsLinear + "\n\n" );
      fprint $fileid ( "SkMotion\n\n" );
      fprint $fileid ( "name \"" + $animName + "\"\n\n" );


      skmMergeAnimLayers();


      string $joints[];  // array to be filled with all joints names
      
	  //Print message indicating number of joints found
	  int $njoints = skmCountJoints( $selectionList[ $j ], $joints );

      print( $njoints + " joints found (" );
      for ( $joint = 0; $joint < $njoints; $joint++ )
      {
         if ( $joint > 5 )
         {
            print( "etc...)\n" );
            break;
         }
         print ( $joints[ $joint ] + ", " );
      }


      // Give Error if NO key attributes found, which means the animation is not properly baked or maybe anim layer problem
      if ( $njoints == 0 )
      {
         fclose $fileid;
         error -showLineNumber true "No key attributes found. Check animation baking, layer setting";
      }


      // Count number of channels
      int $nchannels;
      int $useChannelAttributes = `getAttr ( $animDef + ".UseChannelAttributes" )`;
      if ( $useChannelAttributes )
      {
         $nchannels = 0;

         for ( $i = 0; $i < $curJointsId; $i++ )
         {
            int $useChannelAttributes = `getAttr ( $animDef + ".UseChannelAttributes" )`;
            if ( $useChannelAttributes )
            {
               int $channelAttributePosX = 0;
               int $channelAttributePosY = 0;
               int $channelAttributePosZ = 0;
               int $channelAttributeQuat = 0;

               if ( `objExists ( $joints[ $i ] + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $joints[ $i ] + ".SbodyPosX" )`;
               if ( `objExists ( $joints[ $i ] + ".SbodyPosY" )` )  $channelAttributePosY = `getAttr ( $joints[ $i ] + ".SbodyPosY" )`;
               if ( `objExists ( $joints[ $i ] + ".SbodyPosZ" )` )  $channelAttributePosZ = `getAttr ( $joints[ $i ] + ".SbodyPosZ" )`;
               if ( `objExists ( $joints[ $i ] + ".SbodyQuat" )` )  $channelAttributeQuat = `getAttr ( $joints[ $i ] + ".SbodyQuat" )`;

               if ( $channelAttributePosX )  $nchannels++;
               if ( $channelAttributePosY )  $nchannels++;
               if ( $channelAttributePosZ )  $nchannels++;
               if ( $channelAttributeQuat )  $nchannels++;
            }
         }
      }
      else
      {
         if ( !( $isFacial ) )
         {
            $nchannels = $njoints + 3; // all joints' rotations + root 3 translations
         }
         else
         {
            $nchannels = $njoints * 4; // all joints have 1 rotation and 3 translations
         }
      }

      print ( $nchannels + " channels found\n" );

      fprint $fileid ( "channels " + $nchannels + "\n" );


      int $startFrame = `getAttr( $animDef + ".firstFrameNumber" )`;
      int $endFrame =   `getAttr( $animDef + ".lastFrameNumber" )`;
      int $fps =        `getAttr( $animDef + ".framesPerSecond" )`;

      skmWriteSkm( $startFrame, $endFrame, $joints, $fileid, $fps, $animDef );
	  
	  print "Size of joint list: "  ;
	  print `size $joints` ;
	  print "\n" ;


      //grab synch point values
      int $readyVal =       `getAttr( $animDef + ".readyTime" )`;
      int $strokeStartVal = `getAttr( $animDef + ".strokeStartTime" )`;
      int $emphasisVal =    `getAttr( $animDef + ".emphasisTime" )`;
      int $strokeVal =      `getAttr( $animDef + ".strokeTime" )`;
      int $relaxVal =       `getAttr( $animDef + ".relaxTime" )`;

      if ( !( $readyVal <= $strokeStartVal && $strokeStartVal <= $emphasisVal && $emphasisVal <= $strokeVal && $strokeVal <= $relaxVal ) )
      {
         print( "ERROR: Invalid Synch Point Times - Invalid times given for Ready, Stroke, Relax: make sure Relax occurs after Ready and Stroke etc. Hit help button for more information" );
      }

      //convert synch point values from frames to seconds
      float $readySeconds =       float( $readyVal - $startFrame ) / $fps;
      float $strokeStartSeconds = float( $strokeStartVal - $startFrame ) / $fps;
      float $emphasisSeconds =    float( $emphasisVal - $startFrame ) / $fps;
      float $strokeSeconds =      float( $strokeVal - $startFrame ) / $fps;
      float $relaxSeconds =       float( $relaxVal - $startFrame ) / $fps;

      //print synch point values
      fprint $fileid ( "\n\n" );
      fprint $fileid ( "ready time: "+ $readySeconds + "\n" );
      fprint $fileid ( "strokeStart time: "+ $strokeStartSeconds + "\n" );
      fprint $fileid ( "emphasis time: "+ $emphasisSeconds+ "\n" );
      fprint $fileid ( "stroke time: " + $strokeSeconds + "\n" );
      fprint $fileid ( "relax time: "+ $relaxSeconds + "\n" );
   }

   fclose( $fileid );

   print( "Export done - " + $animName + "\n\n" );

   return 1;
}


global proc skmExport( string $animDef )
{
   // Main entry point for exporting a single .skm
   // If you wish to define your own output filename, call skmExportFile().
   // If you wish to export all .skm's defined, call skmExportAll()
	print ("Running: proc: skmExport( $animDef=" + $animDef + " ) \n") ;

   string $file = `getAttr( $animDef + ".outputFile" )`;
  
   // resolve file path according to project root directory
   string $projectRoot = `workspace -en ""`;
   $file = substituteAllString($file, "\\", "/");   
   string $afterSubstitute = substituteAllString($file, "//", "*");  
   if ($afterSubstitute == $file)
   {
     string $absoluteFile = substituteAllString($file, ":", "");
	 if ($absoluteFile == $file)  $file = $projectRoot + $file;
   }
   else
   {
     if ($afterSubstitute != $file)
	 {
       string $tokens[];
       int $numTokens = `tokenize $afterSubstitute "*" $tokens`;
	   $file = $projectRoot + $tokens[$numTokens - 1];
	 }
   }
   $file = `workspace -en $file`;   
   skmExportFile( $file, $animDef );
}


global proc skmExportAll()
{
   // Main entry point for exporting .skm files
   // This function will export all .skm's defined in this file
   // If you wish to export a single .skm, use skmExport() above.
	print "Running: global proc: skmExportAll() \n" ;
   
   global int $partialExportToggle;
   string $root ;
   string $AllRoots[] ;
   string $AllPeRoots[] ;


   select -hi "*SmartbodyExportOptions";
   string $animDefList[] = `ls -sl`;
   for ( $animDef in $animDefList )
   {
      if ( !startsWith( $animDef, "AnimDef_" ) )
      {
         continue;
      }


		//search scene for object named $root
		$root = `getAttr( $animDef + ".skeletonRoot" )`;
		$AllRoots = `SbmGetAllNamed( $root )` ;
		if (`size $AllRoots` > 1) {
			error ("More than one object found named: " + $root + "\n") ;
		}
		if (`size $AllRoots` < 0) {
			error ("No object found named: " + $root + "\n") ;
		}
		else {
			$root = $AllRoots[0] ;
		}
		
		//original
		//$root = `getAttr( $animDef + ".skeletonRoot" )`;

		if ( $partialExportToggle == 0 )
		{
			string $peRootName = `getAttr ( $animDef + ".partialExportRoot" )` ;
			 
			$AllPeRoots = `SbmGetAllNamed( $peRootName )` ;
			if (`size $AllPeRoots` > 1) {
				error ("More than one object found named: " + $root + "\n") ;
			}
			if (`size $AllPeRoots` < 0) {
				error ("No object found named: " + $root + "\n") ;
			}
			else { 
				$peRootName = $AllPeRoots[0] ;
				select -r $peRootName;
			}
		}
		else
		{
			select -r $root ;   // <-Why select this?
		}

      skmExport( $animDef );
   }
}






////////////////////////////////////////////////////////////////
//  GUI CODE
////////////////////////////////////////////////////////////////


global proc string skmGetSelectedAnimDefName()
{
   // Get animation definition name
   string $selAnim[] = `textScrollList -q -selectItem scrollListAnim`;
   return ( "AnimDef_" + $selAnim[ 0 ] );
}


global proc skmCheckAnimDef()
{
   // this function is called every time the UI is loaded, to make sure maya file has the right attributes created
   // (for backward compatibility).  But it doesn't modify attributes that already exist.

   global string $skmVersion;

   if ( !`objExists SmartbodyExportOptions` )
   {
      group -empty -name "SmartbodyExportOptions";
      setAttr "SmartbodyExportOptions.visibility" 0;
   }


   // Check to see if there are any existing animation definitions
   select -hi SmartbodyExportOptions;
   string $animDefList[] = `ls -sl`;

   int $numAnimDefs = 0;
   for ( $animDef in $animDefList )
   {
      if ( startsWith( $animDef, "AnimDef_" ) )
      {
         $numAnimDefs++;
      }
   }

   if ( $numAnimDefs == 0 )
   {
      $animDefList = { "AnimDef_DefaultAnim" };
   }

   for ( $animDef in $animDefList )
   {
      if ( !startsWith( $animDef, "AnimDef_" ) )
      {
         continue;
      }

      if ( !`objExists $animDef` )
      {
         group -empty -name $animDef -parent SmartbodyExportOptions;
      }

      if ( !`objExists ( $animDef + ".Version" )` )
      {
         addAttr -longName "Version" -dataType "string" $animDef;
         setAttr -type "string" ( $animDef + ".Version" ) $skmVersion;
      }

      if ( !`objExists ( $animDef + ".UseChannelAttributes" )` )
      {
         addAttr -longName "UseChannelAttributes" -attributeType bool $animDef;
      }

      if ( !`objExists ( $animDef + ".framesPerSecond" )` )
      {
         addAttr -longName "framesPerSecond" -attributeType "long" -min 1 -dv 30 $animDef;
      }

      if ( !`objExists ( $animDef + ".firstFrameNumber" )` )
      {
         addAttr -longName "firstFrameNumber" -attributeType "long" $animDef;
      }

      if ( !`objExists ( $animDef + ".lastFrameNumber" )` )
      {
         addAttr -longName "lastFrameNumber" -attributeType "long" $animDef;
      }

      if ( !`objExists ( $animDef + ".readyTime" )` )
      {
         addAttr -longName "readyTime" -attributeType "double" $animDef;
      }

      if ( !`objExists ( $animDef + ".strokeStartTime" )` )
      {
         addAttr -longName "strokeStartTime" -attributeType "double" $animDef;
      }

      if ( !`objExists ( $animDef + ".emphasisTime" )` )
      {
         addAttr -longName "emphasisTime" -attributeType "double" $animDef;
      }

      if ( !`objExists ( $animDef + ".strokeTime" )` )
      {
         addAttr -longName "strokeTime" -attributeType "double" $animDef;
      }

      if ( !`objExists ( $animDef + ".relaxTime" )` )
      {
         addAttr -longName "relaxTime" -attributeType "double" $animDef;
      }

      if ( !`objExists ( $animDef + ".skeletonRoot" )` )
      {
         addAttr -longName "skeletonRoot" -dataType "string" $animDef;
         setAttr -type "string" ( $animDef + ".skeletonRoot" ) "base";
      }

      if ( !`objExists ( $animDef + ".partialExportRoot" )` )
      {
         addAttr -longName "partialExportRoot" -dataType "string" $animDef;
         setAttr -type "string" ( $animDef + ".partialExportRoot" ) "base";
      }

      if ( !`objExists ( $animDef + ".outputFile" )` )
      {
         addAttr -longName "outputFile" -dataType "string" $animDef;
         string $animSubstring = substituteAllString( $animDef, "AnimDef_", "" );
         setAttr -type "string" ( $animDef + ".outputFile" ) ( $animSubstring + ".skm" );
      }
   }
}


global proc skmUpdateAnimUI()
{
   // look in all animDefs in the attributes, and add any that are missing to the scroll box
   select -hi SmartbodyExportOptions;
   string $animDefList[] = `ls -sl`;
   string $scrollListItems[] = `textScrollList -q -allItems scrollListAnim`;
   for ( $anim in $animDefList )
   {
      if ( !startsWith( $anim, "AnimDef_" ) )
      {
         continue;
      }

      string $animSubstring = substituteAllString( $anim, "AnimDef_", "" );

      int $found = 0;
      for ( $i in $scrollListItems )
      {
         if ( $animSubstring == $i )
         {
            $found = 1;
         }
      }

      if ( !$found )
      {
         textScrollList -e -append $animSubstring scrollListAnim;
      }
   }


   int $selectedAnim[] = `textScrollList -q -selectIndexedItem scrollListAnim`;
   if ( $selectedAnim[ 0 ] == 0 )
   {
      textScrollList -e -selectIndexedItem 1 scrollListAnim;
   }


   // update UI based on the selected item in the scroll box
   string $animDef = skmGetSelectedAnimDefName();


   int $channelAttributesSelected = `getAttr( $animDef + ".UseChannelAttributes" )`;
   checkBox -e -value $channelAttributesSelected channelAttributesBox;

   int $firstFrame = `getAttr( $animDef + ".firstFrameNumber" )`;
   intSliderGrp -e -value $firstFrame skmFirstFrameSlider;

   int $lastFrame = `getAttr( $animDef + ".lastFrameNumber" )`;
   intSliderGrp -e -value $lastFrame skmLastFrameSlider;

   int $readyFrame = `getAttr( $animDef + ".readyTime" )`;
   intSliderGrp -e -minValue $firstFrame -maxValue $lastFrame -value $readyFrame sliderReady;

   int $strokeStartFrame = `getAttr( $animDef + ".strokeStartTime" )`;
   intSliderGrp -e -minValue $firstFrame -maxValue $lastFrame -value $strokeStartFrame sliderStrokeStart;

   int $emphasisFrame = `getAttr( $animDef + ".emphasisTime" )`;
   intSliderGrp -e -minValue $firstFrame -maxValue $lastFrame -value $emphasisFrame sliderEmphasis;

   int $strokeEndFrame = `getAttr( $animDef + ".strokeTime" )`;
   intSliderGrp -e -minValue $firstFrame -maxValue $lastFrame -value $strokeEndFrame sliderStrokeEnd;

   int $relaxFrame = `getAttr( $animDef + ".relaxTime" )`;
   intSliderGrp -e -minValue $firstFrame -maxValue $lastFrame -value $relaxFrame sliderRelax;

   int $fps = `getAttr( $animDef + ".framesPerSecond" )`;
   intSliderGrp -e -value $fps sliderFps;

   string $skeletonRoot = `getAttr( $animDef + ".skeletonRoot" )`;
   textFieldGrp -e -text $skeletonRoot skmRootField;

   string $projectRootDir = `workspace -en ""`;
   textFieldGrp -e -text $projectRootDir skmProjectRootDir;
   
   string $outputFile = `getAttr( $animDef + ".outputFile" )`;
   string $name = basename( $outputFile, "");
   string $dirname = dirname( $outputFile );
   textFieldGrp -e -text $name skmOutputFile;
   textFieldGrp -e -text $dirname skmOutputPath;

   string $peRootName = `getAttr( $animDef + ".partialExportRoot" )`;
   textFieldGrp -e -text $peRootName skmPartialExportRootField;
}


global proc int skmFileCb( string $fileDir, string $fileType )
{
   //--- here, get the relative path
   string $absPath = $fileDir;
   string $refPath = `workspace -en ""`;
   
   string $finalDir = substituteAllString($absPath, $refPath, "");
   if ($finalDir == $absPath)
     textFieldGrp -e -text $absPath skmOutputPath;  
   else
     textFieldGrp -e -text $finalDir skmOutputPath;       
   
   skmUpdateOutput();
   return 1;
}


global proc skmAddAnimDef()
{
   string $result = `promptDialog -title "Define New Animation" -message "Animation Name?"
                    -button "OK" -button "Cancel"
                    -defaultButton "OK" -cancelButton "Cancel"
                    -dismissString "Cancel"`;

   if ( $result == "OK" )
   {
      $newAnimName = `promptDialog -query -text`;

      // add the animdef attribute
      group -empty -name ( "AnimDef_" + $newAnimName ) -parent SmartbodyExportOptions;

      // populate the attribute with all data
      skmCheckAnimDef();

      // select the newly created item in the UI and update it's values
      // call update twice, once to add the entry to the list, other to update the values after selecting it
      skmUpdateAnimUI();
      textScrollList -e -selectItem $newAnimName scrollListAnim;
      skmUpdateAnimUI();
   }
}


global proc skmDeleteAnimDef()
{
   $selAnim = `textScrollList -q -selectItem scrollListAnim`;
   textScrollList -e -removeItem $selAnim scrollListAnim;
   delete ( "AnimDef_" + $selAnim[ 0 ] );
   skmUpdateAnimUI();
}


global proc skmRenameAnimDef()
{
   // Create "new name" prompt window
   string $PromptResult = `promptDialog -title "Rename Selected Animation" -message "New Animation Name?"
                          -button "Rename" -button "Cancel"
                          -defaultButton "Rename" -cancelButton "Cancel"
                          -dismissString "Cancel"`;

   if ( $PromptResult == "Rename" )
   {
      string $newAnimName = `promptDialog -q -text`;

      string $selAnim[] = `textScrollList -q -selectItem scrollListAnim`;

      rename( "AnimDef_" + $selAnim[ 0 ] ) ( "AnimDef_" + $newAnimName );

      textScrollList -e -removeItem $selAnim[ 0 ] scrollListAnim;
      textScrollList -e -append $newAnimName scrollListAnim;
      textScrollList -e -selectItem $newAnimName scrollListAnim;

	  //update the "Output Filename" field
	  textFieldGrp -e -text ($newAnimName + ".skm") -forceChangeCommand "skmOutputFile";
	  
      skmUpdateAnimUI();
   }
}


global proc skmChannelAttributesOn()
{
   string $animDef = skmGetSelectedAnimDefName();
   setAttr ( $animDef + ".UseChannelAttributes" ) true;
}


global proc skmChannelAttributesOff()
{
   string $animDef = skmGetSelectedAnimDefName();
   setAttr ( $animDef + ".UseChannelAttributes" ) false;
}


global proc skmToggleIsFacial()
{
   global int $isFacial;

   if ( $isFacial )
   {
      $isFacial = 0;
   }
   else
   {
      $isFacial = 1;
   }
}


global proc skmTogglePartialExport()
{
   global int $partialExportToggle;
   if( $partialExportToggle )
   {
      $partialExportToggle = 0;
   }
   else
   {
      $partialExportToggle = 1;
   }
}


global proc skmInfoPressed()
{
   confirmDialog -title "Ready Stroke Relax help" -message "Ready: Anticipation for the stroke (or action)  \nStroke: Climax of Action- point of greatest emphasis \nRelax: Follow-Thru and Settle of the action \nfor more information consult http://twiki.isi.edu/Public/BMLSpecification" -button "close"  -defaultButton "close";
}


global proc skmFpsUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   $fps = `intSliderGrp -q -value sliderFps`;
   setAttr( $animDef + ".framesPerSecond" ) $fps;
}


global proc skmFirstFrameUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();

   string $SeqPointSLiders[] =
   {
      "sliderReady",
      "sliderStrokeStart",
      "sliderEmphasis",
      "sliderStrokeEnd",
      "sliderRelax"
   };

   string $SeqPointAttrs[] =
   {
      "readyTime",
      "strokeStartTime",
      "emphasisTime",
      "strokeTime",
      "relaxTime"
   };

   int $FirstFrame = `intSliderGrp -query -value "skmFirstFrameSlider"`;

   // set value for first frame
   currentTime -edit $FirstFrame; // UPDATE THE DISPLAY
   setAttr ( $animDef + ".firstFrameNumber" ) $FirstFrame;

   // if attr in AnimDefs is less than minimum value, increase it to minimum value
   for ( $Attr in $SeqPointAttrs )
   {
      if ( `getAttr ( $animDef + "." + $Attr )` < $FirstFrame )
      {
         setAttr ( $animDef + "." + $Attr ) $FirstFrame;
      }
   }

   //update UI
   for ( $Slider in $SeqPointSLiders )
   {
      // set minimum value of slider to be first frame number
      intSliderGrp -edit -min $FirstFrame $Slider;

      // if current values are less than min value update them to be min value
      if ( `intSliderGrp -query -value $Slider` < $FirstFrame )
      {
         intSliderGrp -edit -value $FirstFrame $Slider;
      }
   }
}


global proc skmLastFrameUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();

   string $SeqPointSLiders[] =
   {
      "sliderReady",
      "sliderStrokeStart",
      "sliderEmphasis",
      "sliderStrokeEnd",
      "sliderRelax"
   };

   string $SeqPointAttrs[] =
   {
      "readyTime",
      "strokeStartTime",
      "emphasisTime",
      "strokeTime",
      "relaxTime"
   };

   //int $frameNumber = `intSliderGrp -query -value skmLastFrameSlider`;
   int $LastFrame = `intSliderGrp -query -value skmLastFrameSlider`;

   // set value for last frame
   currentTime -edit $LastFrame; // UPDATE THE DISPLAY
   setAttr ( $animDef + ".lastFrameNumber" ) $LastFrame;

   // if attr in AnimDefs is less than minimum value, increase it to minimum value
   for ( $Attr in $SeqPointAttrs)
   {
      if ( `getAttr ( $animDef + "." + $Attr )` > $LastFrame )
      {
         setAttr ( $animDef + "." + $Attr ) $LastFrame;
      }
   }

   // update UI
   for ($Slider in $SeqPointSLiders)
   {
      // set minimum value of slider to be first frame number
      intSliderGrp -edit -max $LastFrame $Slider;

      // if current values are less than min value update them to be min value
      if ( `intSliderGrp -query -value $Slider` > $LastFrame )
      {
         intSliderGrp -edit -value $LastFrame $Slider;
      }
   }
}


global proc skmReadyUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   int $frameNumber = `intSliderGrp -query -value sliderReady`; // the animator is at this framenumber
   setAttr ( $animDef + ".readyTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc skmStrokeStartUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   int $frameNumber = `intSliderGrp -query -value sliderStrokeStart`; // the animator is at this framenumber
   setAttr ( $animDef + ".strokeStartTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc skmEmphasisUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   int $frameNumber = `intSliderGrp -query -value sliderEmphasis`; // the animator is at this framenumber
   setAttr ( $animDef + ".emphasisTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc skmStrokeUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   int $frameNumber = `intSliderGrp -query -value sliderStrokeEnd`; // the animator is at this framenumber
   setAttr ( $animDef + ".strokeTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc skmRelaxUpdate()
{
   string $animDef = skmGetSelectedAnimDefName();
   int $frameNumber = `intSliderGrp -query -value sliderRelax`; // the animator is at this framenumber
   setAttr ( $animDef + ".relaxTime" ) $frameNumber;
   currentTime -edit $frameNumber; // UPDATE THE DISPLAY
}


global proc skmUpdateSkeletonRoot()
{
   string $animDef = skmGetSelectedAnimDefName();
   $skeletonRoot = `textFieldGrp -q -text skmRootField`;
   setAttr -type "string" ( $animDef + ".skeletonRoot" ) $skeletonRoot;
   skmUpdatePartialExportJoint();
}


// For partial animation exporting
// Update the joint that you want to export from
global proc skmUpdatePartialExportJoint()
{
   string $peRootName = `textFieldGrp -q -text skmPartialExportRootField`;

   string $animDef = skmGetSelectedAnimDefName();


   string $skeletonRoot = `getAttr( $animDef + ".skeletonRoot" )`;

   select -cl;
   int $flag = `joint -exists $peRootName`;
   if( $flag == 0 )
   {
      warning -showLineNumber true "partial not exist, please re-enter";
      textFieldGrp -e -text $skeletonRoot skmPartialExportRootField;   
   }
   $flag = 0;
   string $children[] = `ls -dag $skeletonRoot`; 
   int $i;
   for( $i = 0 ; $i < size($children); $i = $i + 1)
      if( $children[ $i ] == $peRootName ) {$flag = 1; break;} 
   if($flag == 0) 
   {
      warning -showLineNumber true "partial joint is not under root hierarchy!";
      textFieldGrp -e -text $skeletonRoot skmPartialExportRootField;   
   }
   
   string $peRootName = `textFieldGrp -q -text skmPartialExportRootField`;
   setAttr -type "string" ( $animDef + ".partialExportRoot" ) $peRootName ;
}


global proc skmUpdateOutput()
{
   // outputFile Attribute now is composed of directory name and file name
	string $animDef = skmGetSelectedAnimDefName();
	string $outputFileName = `textFieldGrp -q -text skmOutputFile`;
	string $outputFilePath = `textFieldGrp -q -text skmOutputPath`;
	string $outputFile;
	
	if ( $outputFilePath != "" ) {
	   $outputFile = $outputFilePath + "/" + $outputFileName;
	}
	else {
		$outputFile = $outputFileName ;
	}
	setAttr -type "string" ( $animDef + ".outputFile" ) $outputFile ;
}

global proc showExportingChannelsInfoPressed()
{
   confirmDialog -title "Exporting Channels Manager Help" -message "Show the channels after you are ready to export the .skm files, otherwise it maybe incorrect. This only works when Use Channel Attributes toggle is on.\nYou can select different animDef and re-click on the button to fresh the tree visualization." -button "close"  -defaultButton "close";
}

proc updateChannelAttributes(string $jointName)
{
	int $i;
	for ($i = 0; $i < 4; $i++)
	{
		if ($i == 0) $attribute = $jointName + ".SbodyPosX";
		if ($i == 1) $attribute = $jointName + ".SbodyPosY";
		if ($i == 2) $attribute = $jointName + ".SbodyPosZ";
		if ($i == 3) $attribute = $jointName + ".SbodyQuat";
		
		string $checkBoxName = substituteAllString($attribute, ".", "");
		if (`checkBox -q -exists $checkBoxName`)
		{
			if ( `objExists $attribute` )  
			{
			  int $val = `checkBox -q -value $checkBoxName`;
			  setAttr $attribute $val;
			}
			else
			{
		      int $val = `checkBox -q -value $checkBoxName`;
			  if ($val == 1)
			  {			
				string $tokens[];
				int $numToken = `tokenize $attribute "." $tokens`;
				if ($numToken == 2)
				{
				  addAttr -longName $tokens[1] -attributeType bool -defaultValue 0 $tokens[0];
				  setAttr $attribute 1;
				}
			  }
			}
		}
		else
		{
		  print ($attribute + " Not Exist!\n");
		}
	}
	string $Children[] = `listRelatives $jointName`;	
	for ($i = 0; $i < size($Children); $i = $i + 1)
	{
	  string $type = nodeType($Children[$i]);
	  if ($type != "joint")  continue;
	  updateChannelAttributes($Children[$i]);
	}	  	
}

global proc updateUseChannelAttributes()
{
	// display here
	string $animDef = skmGetSelectedAnimDefName();		
	string $root = `getAttr( $animDef + ".skeletonRoot" )`;
	
	//recursively update channel attribute here
	updateChannelAttributes($root);		
}

global proc printJointChannel(int $useChannelAttributes, string $jointName, int $counter)
{
	global int $isFacial;
	int $i;
	rowColumnLayout -numberOfRows 1 -rowHeight 1 20 -rowSpacing 1 2 -columnAttach 1 "right" 3;
	string $displayJointName;
	if ($counter > 0)
	{
		for ($i = 0; $i < $counter; $i = $i + 1)
			$displayJointName = $displayJointName + "  ";
	}
	$displayJointName = $displayJointName + " * " + $jointName + "  ";
	text -label $displayJointName;
	
	if ($useChannelAttributes)
	{
	  int $channelAttributePosX = 0;
	  int $channelAttributePosY = 0;
	  int $channelAttributePosZ = 0;
	  int $channelAttributeQuat = 0;

	  if ( `objExists ( $jointName + ".SbodyPosX" )` )  $channelAttributePosX = `getAttr ( $jointName + ".SbodyPosX" )`;
	  if ( `objExists ( $jointName + ".SbodyPosY" )` )  $channelAttributePosY = `getAttr ( $jointName + ".SbodyPosY" )`;
	  if ( `objExists ( $jointName + ".SbodyPosZ" )` )  $channelAttributePosZ = `getAttr ( $jointName + ".SbodyPosZ" )`;
	  if ( `objExists ( $jointName + ".SbodyQuat" )` )  $channelAttributeQuat = `getAttr ( $jointName + ".SbodyQuat" )`;
	  
	  checkBox -label "XPos" -value $channelAttributePosX -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosX");
	  checkBox -label "YPos" -value $channelAttributePosY -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosY");
	  checkBox -label "ZPos" -value $channelAttributePosZ -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyPosZ");
	  checkBox -label "Quat" -value $channelAttributeQuat -changeCommand "updateUseChannelAttributes()" ($jointName + "SbodyQuat");
	}
	$counter = $counter + 1;
	string $Children[] = `listRelatives $jointName`;
	setParent ..;		
	for ($i = 0; $i < size($Children); $i = $i + 1)
	{
		string $type = nodeType($Children[$i]);
		if ($type != "joint")  continue;
		printJointChannel($useChannelAttributes, $Children[$i], $counter);
	}
	$counter = $counter - 1;	
}

global proc showExportingChannelsWin()
{
	if ((`window -exists showExportingChannelsWin`) == true)
	{
		deleteUI showExportingChannelsWin;
		windowPref -remove showExportingChannelsWin;
	}

	// create UI Window here
	window -title ("Exporting Channels Manager") -resizeToFitChildren true -sizeable true -width 600 -height 800 showExportingChannelsWin;
	// display here
	string $animDef = skmGetSelectedAnimDefName();
	string $root = `getAttr( $animDef + ".skeletonRoot" )`; 
	int $useChannelAttributes = `getAttr ( $animDef + ".UseChannelAttributes" )`;

	// recursive print tree visualization
	int $counter  = 0;
	scrollLayout;
	columnLayout -adjustableColumn true -columnAttach "both" 5;
	printJointChannel($useChannelAttributes, $root, $counter);	   

	showWindow showExportingChannelsWin;
}

global proc skmExportButton()
{
   skmExportAll();
}


global proc skmExportGUI()
{
	// This creates the main UI window

	global string $skmVersion;
	global int $isFacial;

	if ( ( `window -exists skmMainWin` ) == true )
	{
		deleteUI skmMainWin;
		windowPref -remove skmMainWin;
	}

	skmCheckAnimDef();

	//BUILD UI WINDOW
	window -title ( "SKM Exporter v" + $skmVersion ) -resizeToFitChildren true -sizeable true skmMainWin;
	columnLayout -adjustableColumn true -columnAttach "both" 5;
		frameLayout -label "Animation Definitions" -borderStyle etchedIn -collapsable false -collapse 0;
			columnLayout -adjustableColumn true -rowSpacing 2 -columnOffset "both" 10;
			textScrollList  -numberOfRows 15 -width 250 -allowMultiSelection false
							-showIndexedItem 4 -selectCommand skmUpdateAnimUI scrollListAnim;
			rowColumnLayout -numberOfRows 1 -rowHeight 1 20 -rowSpacing 1 2 -columnAttach 1 "right" 3;
				button -label "Create Animation" -command "skmAddAnimDef" -align "center";
				button -label "Rename Animation" -command "skmRenameAnimDef" -align "center";
				button -label "Delete Animation" -command "skmDeleteAnimDef" -align "center";
				setParent .. ;
			setParent .. ;
		setParent .. ;
	checkBox -label "Use Channel Attributes" -onCommand "skmChannelAttributesOn" -offCommand "skmChannelAttributesOff" -align "left" channelAttributesBox;
	checkBox -editable false -label "Facial Animations" -changeCommand "skmToggleIsFacial" -value false -align "left" facialBox;
	checkBox -editable false -label "Partial Animation Exporting- ON: Zero-out OFF: Eliminate Other joints" -changeCommand "skmTogglePartialExport" -value false -align "left" partialExportBox;

	frameLayout -label "Animation Length & Synch Points" -borderStyle etchedIn -collapsable false -collapse 0;
		columnLayout -adj true;
			intSliderGrp -label "First Frame:" -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmFirstFrameUpdate "skmFirstFrameSlider";
			intSliderGrp -label "Last Frame:"  -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmLastFrameUpdate "skmLastFrameSlider";
			columnLayout -adjustableColumn true -rowSpacing 2 -columnOffset "both" 10;
				button -label "Stroke, Ready, Relax Help" -align "center" -command skmInfoPressed;
				setParent .. ;
			intSliderGrp -label "Ready End Frame"     -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmReadyUpdate "sliderReady";
			intSliderGrp -label "Stroke Start Frame:" -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmStrokeStartUpdate "sliderStrokeStart";
			intSliderGrp -label "Emphasis Frame:"     -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmEmphasisUpdate "sliderEmphasis";
			intSliderGrp -label "Stroke End Frame:"   -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmStrokeUpdate "sliderStrokeEnd";
			intSliderGrp -label "Relax End Frame:"    -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmRelaxUpdate "sliderRelax";
			setParent .. ;
		setParent .. ;
	frameLayout -label "Export Setup" -borderStyle etchedIn -collapsable false -collapse 0;
		columnLayout -adjustableColumn true;
			intSliderGrp -label "Frames per Seconds:" -adjustableColumn 3 -columnWidth 2 50 -columnAttach 1 "right" 5 -field true -fieldMinValue -10000 -fieldMaxValue 10000 -changeCommand skmFpsUpdate -minValue 1 -value 30 "sliderFps" ; //<- was "skmFps"
			textFieldGrp -label "Skeleton Root Joint:" -adjustableColumn 2 -columnAttach 1 "right" 5 -changeCommand skmUpdateSkeletonRoot "skmRootField" ;
			textFieldGrp -label "Partial Exporting, From Joint:" -adjustableColumn 2 -columnAttach 1 "right" 5 -changeCommand skmUpdatePartialExportJoint "skmPartialExportRootField" ;
			textFieldGrp -label "Project Root Directory:" -adjustableColumn 2 -columnAttach 1 "right" 5 -ed false "skmProjectRootDir" ;		 
			textFieldGrp -label "Output Pathname:" -adjustableColumn 2 -columnAttach 1 "right" 5 -changeCommand skmUpdateOutput "skmOutputPath" ;
			textFieldGrp -label "Output Filename:" -adjustableColumn 2 -columnAttach 1 "right" 5 -editable 0 -changeCommand skmUpdateOutput "skmOutputFile" ;
			columnLayout -adjustableColumn true -rowSpacing 2 -columnOffset "both" 10;
				button -label "Browse Output File" -command "fileBrowserDialog -m 4 -fc \"skmFileCb\" -an \"Select\" -om \"SaveAs\"";
				setParent .. ;
			setParent .. ;
		setParent .. ;
	frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -labelVisible false;
		columnLayout -adjustableColumn true -rowSpacing 5 -columnOffset "both" 10;
			button -label "Show Exporting Channels" -command "showExportingChannelsWin()";
			button -label "Show Exporting Channels Help" -command showExportingChannelsInfoPressed;
			setParent .. ;
		setParent .. ;
	frameLayout -borderStyle etchedIn -collapsable false -collapse 0 -labelVisible false;
		columnLayout -adjustableColumn true -rowSpacing 5 -columnOffset "both" 10;
			button -label "Export All Animations" -command "skmExportButton()";
			setParent .. ;
		setParent .. ;


   skmUpdateAnimUI();


   showWindow skmMainWin;
}



/*----------------------------------------
SCRIPT INFO
  - joints can have no key data or rotation data, only root may contain translation
  - The order of the joint rotations is considered to be Euler XYZ
  - You cannot change the default name of the animation curves (they have to have the form jointName_rotateX, etc)
  - If the animation uses IK handles, it must be baked before the export
  - To make sure the animation export will be fine, remove all IK handles and check if the animation in Maya is still correct
  - Although the script checks it, it is a good idea to change the settings to cms

KNOWN ISSUES
 - under certain conditions, which I have not been able to determine, the output file path will disappear

VERSION HISTORY:
  0.1 - first version
  0.2 - smaller files exported (less decimals used)
  0.3 - rounding 5th decimal
  0.4 - corrected recursing into joint hierarchy even if joint has no keys
  Modifications by Ashok Basawapatna
  0.5 - interim solution to allow artists to specify ready, stroke, and relax using the frame numbers (a more graphical solution should be constructed), frame numbers are converted into time values and written to the bottom of the skm in the followin format
    ready time: 0.9333333333
    stroke time: 1.433333333
    relax time: 1.933333333 
  0.6 - another interim solution-- gives the artist access to the time slider for all sliders in order to specify ready, stroke, and relax;start and end frame again writes the times to the bottom of the skm
    adds help button to explain ready, stroke, relax to the artist and also has error check to make sure ready, stroke, relax are valid times
  0.7 - changes by Matt Liewer (liewer@ict.usc.edu)
    disabled timeline resizing when first and last frame values changed
    put all export option attributes onto one node "SmartbodyExportOptions"
    commented code a bit
    general streamlinining of script
    re-organized interface
  0.8 - changes by Matt Liewer (liewer@ict.usc.edu)
    when UI is opened it will check for info created by older version of the exporter and upadte this info to new system
    can now define and export multiple animations per file
*/
